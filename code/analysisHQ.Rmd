---
title: "analysisHQ"
author: "JD Pruett"
date: "2025-04-04"
output: html_document
---

# Environment Setup --------------------------------------
```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = '/Users/jdpruett/Desktop/CES Accuracy Analysis')

# Load functions and structures from other utility scripts
source("recoding_utilities.R")
source("data_structures.R")
source("election_return_utilities.R")
```

```{r, echo=False, warnings=FALSE, message=FALSE}
# create notin operator
`%notin%` <- Negate(`%in%`)

# Packages & working directory
pckgs <- c("haven", "readxl", "ipumsr", "here", "dplyr", "cdlTools", "anesrake", "writexl", "tidyverse", "rlang", "tibble", "naniar", "weights", "lubridate", "openxlsx", "cpsR")

#For now, this installation is not working
#"zipcodeR"

# This downloads any necessary packages
# if (any(pckgs %notin% rownames(installed.packages())==TRUE)){
# install.packages(pckgs, repos = c(CRAN = "http://cloud.r-project.org"))}

invisible(sapply(pckgs, FUN = require, character.only = TRUE))

# Set working directory.
set_here()
```

# Read-in Data ----------------------------------------------
## CES Datasets
```{r, Read-in CES Data}
CES_06_raw <- read_dta(here("data/CES Data/CES06/cces_2006_common.dta"))
CES_08_raw <- read_dta(here("data/CES Data/CES08/cces_2008_common.dta"))
CES_10_raw <- read_dta(here("data/CES Data/CES10/cces_2010_common_validated.dta"))
CES_12_raw <- read_dta(here("data/CES Data/CES12/commoncontent2012.dta"))
CES_14_raw <- read_dta(here("data/CES Data/CES14/CCES14_Common_Content_Validated.dta"))
CES_16_raw <- read_dta(here("data/CES Data/CES16/CCES16_Common_OUTPUT_Feb2018_VV.dta"))
CES_18_raw <- read_dta(here("data/CES Data/CES18/cces18_common_vv.dta"))
CES_20_raw <- read_dta(here("data/CES Data/CES20/CES20_Common_OUTPUT_vv.dta"))
CES_22_raw <- read_dta(here("data/CES Data/CES22/CES_2022_Common_Output.dta"))
```


## Election Validation Datasets
### National Elections
```{r}
# Governor, U.S. Senate, President
Governor_0622 <- read_excel("data/Election Validation/Final Sets - Clean Fixed/Governor_0622_clean_fixed.xlsx")
Senate_0622 <- read_excel("data/Election Validation/Final Sets - Clean Fixed/Senate_0622_clean_fixed.xlsx")
President_0820 <- read_excel("data/Election Validation/Final Sets - Clean Fixed/[FIN-FIX] President 2008-2020 clean fixed.xlsx")

# U.S. House
house_data_path <- "data/Election Validation/Final Sets - Clean Fixed/[FIN-FIX] House 2006-2022 clean fixed.xlsx"
house_sheet_names <- excel_sheets(house_data_path)
house_sheet_names <- house_sheet_names[house_sheet_names != "Sources"]
House_0622 <- house_sheet_names %>%
  lapply(function(sheet) {
    data <- read_excel(path = house_data_path, sheet = sheet)
    data$state <- toupper(data$state)
    return(data)
  }) %>%
  bind_rows()

House_0622 <- House_0622 %>%
  mutate(party_simplified = case_when(
    party_detailed %in% c("DEM", "ADDITIONAL (D)", "ADDITIONAL(D)", "DNL", "DEMOCRATIC-FARMER-LABOR", "DEMOCRATIC") ~ "DEM",
    party_detailed %in% c("ADDITIONAL (R)", "ADDITIONAL(R)") ~ "REP",
    TRUE ~ party_simplified
  ))
```

### State Elections
```{r warning=FALSE}
# State-level elections master file
State_race_master_table <- read_excel("data/Election Validation/Final Sets - Clean Fixed/[FIN-FIX] Historical election results data (2006 - 2023) clean fixed.xlsx")
State_race_master_table$`Election date` <- as.POSIXct(format(State_race_master_table$`Election date`, "%Y-%m-%d"))

# Parsing state-level master file into individual elections
## State senate
State_senate_full <- State_race_master_table[grepl("\\b(senate|senator|SS|SD|KYSENATOR)\\b", State_race_master_table[["Office/district"]], ignore.case = TRUE), ]

# State representative
State_house_full <- State_race_master_table[grepl("\\b(house|assembly|representative|partyresentative|State Rep.|SR|HD|assemblymember|KYREPRESENTATIVE|StateRepresentative|HouseDistrict)\\b|State Rep\\.", State_race_master_table[["Office/district"]], ignore.case = TRUE), ]

# Attorney general
Attorney_general_full <- State_race_master_table[grepl("Attorney", State_race_master_table[["Office/district"]], ignore.case = TRUE), ]

# Secretary of state
Secretary_of_state_full <- State_race_master_table[grepl("Secretary|Secratary", State_race_master_table[["Office/district"]], ignore.case = TRUE), ]
```

### Misc.
```{r}
# CES assigned some respondents to incorrect congressional district in 2020
NC_flag_df <- read.csv("data/misc/NC_responents_incorrect_CD.csv") %>%
  filter(cd_change_flag_post == 1)

# This is a list of all the races that should be skipped because they were asked about in the CES but did not actually occur
skip_conditions <- read.xlsx("data/misc/skip_conditions_final.xlsx")
```

## CPS Datasets
```{r}
# Set IPUMS API Key (specific to user, free to acquire on IPUMS site)
USER_IPUMS_API_KEY = "59cba10d8a5da536fc06b59dd33fd321a4eb480fa8fe8ad46c9d0d3e"
set_ipums_api_key(USER_IPUMS_API_KEY, save = TRUE, overwrite = FALSE)
```

### Prep monthly sample codes and variables
This is necessary to use the IPUMS API to download CPS data.
```{r}
# All
cps_vars_all <- c("WTFINL", "EARNWT", "VOSUPPWT", "STATEFIP", "SEX", "EDUC", "AGE", "CITIZEN", "HISPAN", "OCC", "VETSTAT", "REGION", "EMPSTAT", "CLASSWKR", "UNION", "FAMINC", "VOTERES", "VOREG", "VOTED", "VOWHYNOT", "VOTEHOW")

# 2006
cps_sample_2006 = c('cps2006_01s', 'cps2006_02b', 'cps2006_03b', 'cps2006_04b', 'cps2006_05s', 'cps2006_06s', 'cps2006_07b', 'cps2006_08s', 'cps2006_09s', 'cps2006_10s', 'cps2006_11s', 'cps2006_12s')
# 2008
cps_sample_2008 = c('cps2008_01s', 'cps2008_02b', 'cps2008_03b', 'cps2008_04b', 'cps2008_05s', 'cps2008_06s', 'cps2008_07b', 'cps2008_08s', 'cps2008_09s', 'cps2008_10s', 'cps2008_11s', 'cps2008_12s')
# 2010
cps_sample_2010 = c('cps2010_01s', 'cps2010_02b', 'cps2010_03b', 'cps2010_04b','cps2010_05s', 'cps2010_06s','cps2010_07s', 'cps2010_08s', 'cps2010_09s', 'cps2010_10s', 'cps2010_11s', 'cps2010_12s')
# 2012
cps_sample_2012 = c('cps2012_01s', 'cps2012_02b', 'cps2012_03b', 'cps2012_04b', 'cps2012_05s', 'cps2012_06s', 'cps2012_07s', 'cps2012_08s', 'cps2012_09s', 'cps2012_10s', 'cps2012_11s', 'cps2012_12s')
# 2014
cps_sample_2014 = c('cps2014_01s', 'cps2014_02s', 'cps2014_03b', 'cps2014_04b', 'cps2014_05b', 'cps2014_06s', 'cps2014_07s', 'cps2014_08s', 'cps2014_09s', 'cps2014_10s', 'cps2014_11s', 'cps2014_12s')
# 2016
cps_sample_2016 = c('cps2016_01s', 'cps2016_02s', 'cps2016_03b', 'cps2016_04b', 'cps2016_05b', 'cps2016_06s', 'cps2016_07b', 'cps2016_08s', 'cps2016_09s', 'cps2016_10s', 'cps2016_11s', 'cps2016_12s')
# 2018
cps_sample_2018 = c('cps2018_01s', 'cps2018_02s', 'cps2018_03b', 'cps2018_04b', 'cps2018_05s', 'cps2018_06s', 'cps2018_07s', 'cps2018_08s', 'cps2018_09s', 'cps2018_10s', 'cps2018_11s', 'cps2018_12s')
# 2020
cps_sample_2020 = c('cps2020_01s', 'cps2020_02s', 'cps2020_03b', 'cps2020_04b', 'cps2020_05b', 'cps2020_06s', 'cps2020_07b', 'cps2020_08s', 'cps2020_09b', 'cps2020_10s', 'cps2020_11s', 'cps2020_12s')
# 2022
cps_sample_2022 = c('cps2022_01s', 'cps2022_02s', 'cps2022_03b', 'cps2022_04s', 'cps2022_05s', 'cps2022_06s', 'cps2022_07s', 'cps2022_08s', 'cps2022_09s', 'cps2022_10s', 'cps2022_11s', 'cps2022_12s')

```

### Read in CPS datasets to global environment
```{r}
# All years
extract_codes <- list()

for (year in seq(2006, 2022, by = 2)) {
  suffix <- substr(year, 3, 4)
  extract_name <- paste("CPS Extract for", year)  # Dynamic extract name
  cps_sample_var <- paste("cps_sample", year, sep = "_")  # Dynamic sample variable name
  df_name <- paste("CPS", suffix, "raw", sep = "_")

  
  # Dynamically create the extraction code using the variables
  extract_code <- paste0(
    "  define_extract_cps(\n",
    "    \"", extract_name, "\",\n",
    "    ", cps_sample_var, ",\n",
    "    cps_vars_all) %>%\n",
    "  submit_extract() %>%\n",
    "  wait_for_extract() %>%\n",
    "  download_extract() %>%\n",
    "  read_ipums_micro()"
  )
  
  extract_codes[[df_name]] <- extract_code
}

# Evaluate the constructed extraction codes in the global environment
for (df_name in names(extract_codes)) {
  assign(df_name, eval(parse(text = extract_codes[[df_name]])), envir = .GlobalEnv)
}
```

## Subset datasets --------------
Subset CES to only include relevant variables
```{r}
CES_06_subset_vars <- c(
  "v1000", "v1001", "v1002", "v1003", "v1004", "v2004", "v2018", "v2020", "v3081", "v3083", "v1006", "v2030", "v2073", "v2082", "v2033", "v2032", "v3004", "v4004", "v4006", "v4005", "v4014", "v4015", "v4013", "v4017", "v4018", "v4019", "v4020", "v4021", "v5009", "v5010", "v5011", "v5012", "v5005", "v5006", "v5007", "v5008", "v5001", "v5002", "v5003", "v5004")

CES_08_subset_vars <- c(
  "V100", "V201", "V206", "V207", "V208", "V250", "V251", "V202", "V205", "V204", "V213", "V252", "V253", "V258", "V257", "V247", "V259", "V264", "V501", "V502", "V553", "V555", "V601", "V602", "V603", "V612", "V653", "V655", "V657", "V672", "CC328_1", "CC328_3", "CC334", "CC410", "CC411", "CC411b", "CC412", "CC413", "CC414_2", "CC414_1", "V209", "CC329", "CC333", "V246", "V203", "CC403", "CC405", "CC404", "CC326b", "CC337", "CC337S2", "CC340", "CC338", "V618", "V619")

CES_10_subset_vars <- c(
  "V100", "V101", "V202_post", "V204_post", "V205_post", "V206", "V206_post", "V207", "V208", "V213", "V252", "V254", "V276", "V276_post", "V564_post", "V567_post", "V548_post", "V551_post", "V533_post", "V536_post", "V554_post", "V556_post", "V570_post", "V572_post","V574_post", "V576_post", "CC351", "V209", "V264", "V250", "V246", "V290", "CC401", "V203", "CC403", "CC402a", "CC410a", "CC410b", "CC412", "CC411", "CC413a", "CC413b", "CC413c", "CC413d")

CES_12_subset_vars <- c(
  "V101", "V103", "inputzip", "votereg_f", "regzip", "inputstate", "inputstate_post", "cdid113", "cdid113_post", "gender", "educ", "birthyr", "milstat_1", "milstat_3", "CC351", "votereg", "employ", "employercat", "union", "ownhome", "faminc",
  "hispanic", "CC401", "CC402a", "CC403", "CC410a", "CC410b", "CC355", "CC412", "CC411", "CC413a", "CC413b", "CC413c", "CC413d", "GovCand1Name_post", "GovCand1Party_post", "GovCand2Name_post", "GovCand2Party_post", "SenCand1Name_post", "SenCand1Party_post", "SenCand2Name_post", "SenCand2Party_post", "SenCand3Name_post", "SenCand3Party_post", "HouseCand1Name_post", "HouseCand1Party_post", "HouseCand2Name_post", "HouseCand2Party_post", "HouseCand3Name_post", "HouseCand3Party_post")

CES_14_subset_vars <- c(
  "V101", "weight", "inputzip_post", "votereg_f_post", "regzip_post", "inputstate", "inputstate_post", "cdid", "cdid_post", "gender", "educ", "birthyr", "milstat_1", "milstat_3", "CC351", 
  "votereg", "employ", "union", "ownhome", "faminc",
  "hispanic", "CC401", "CC402a", "CC403", "CC410b", "CC355x", "CC412", "CC411", "CC413a", "CC413b", "CC413c", "CC413d", "GovCand1Name_post", "GovCand1Party_post", "GovCand2Name_post", "GovCand2Party_post", "SenCand1Name_post", "SenCand1Party_post", "SenCand2Name_post", "SenCand2Party_post", "SenCand3Name_post", "SenCand3Party_post", "HouseCand1Name_post", "HouseCand1Party_post", "HouseCand2Name_post", "HouseCand2Party_post", "HouseCand3Name_post", "HouseCand3Party_post")

CES_16_subset_vars <- c(
  "V101", "inputzip_post", "votereg_f_post", "regzip_post", "commonweight_vv", "commonweight_vv_post", "commonweight_vv_lgbt", "commonweight", "commonweight_post", "inputstate", "inputstate_post", "cdid115", "cdid115_post", "gender", "educ", "birthyr", "milstat_1", "milstat_3", "CC16_361", "votereg", "employ", "union", "ownhome", "faminc", "hispanic", "CC16_401", "CC16_402a", "CC16_410a", "CC16_403", "CC16_410b", "CC16_412", "CC16_411", "CC16_413a", "CC16_413b", "CC16_413c", "CC16_413d", "GovCand1Name_post", "GovCand1Party_post", "GovCand2Name_post", "GovCand2Party_post", "GovCand3Name_post", "GovCand3Party_post", "SenCand1Name_post", "SenCand1Party_post", "SenCand2Name_post", "SenCand2Party_post", "SenCand3Name_post", "SenCand3Party_post", "SenCand4Name_post", "SenCand4Party_post", "HouseCand1Name_post", "HouseCand1Party_post", "HouseCand2Name_post", "HouseCand2Party_post", "HouseCand3Name_post", "HouseCand3Party_post", "HouseCand4Name_post", "HouseCand4Party_post", "HouseCand5Name_post", "HouseCand5Party_post", "HouseCand6Name_post", "HouseCand6Party_post", "HouseCand7Name_post", "HouseCand7Party_post", "HouseCand8Name_post", "HouseCand8Party_post", "HouseCand9Name_post", "HouseCand9Party_post", "HouseCand10Name_post", "HouseCand10Party_post", "HouseCand11Name_post", "HouseCand11Party_post")

CES_18_subset_vars <- c(
  "caseid", "inputzip_post", "votereg_f_post", "regzip_post", "commonweight", "commonpostweight", "vvweight", "vvweight_post", "inputstate", "inputstate_post", "cdid116", "cdid116_post", "gender", "educ", "birthyr", "cit1", "milstat_1", "milstat_3", "region", "votereg", "employ", "union", "ownhome", "faminc_new", "hispanic", "CC18_401", "CC18_402a", "CC18_403", "CC18_410b", "CC18_410bx", "CC18_412", "CC18_353x", "CC18_411", "CC18_352x", "CC18_420a", "CC18_420b", "CC18_420c", "CC18_413c", "CC18_413d", "GovCand1Name_post", "GovCand1Party_post", "GovCand2Name_post", "GovCand2Party_post", "GovCand3Name_post", "GovCand3Party_post", "SenCand1Name_post", "SenCand1Party_post", "SenCand2Name_post", "SenCand2Party_post", "SenCand3Name_post", "SenCand3Party_post", "AttCand1Name", "AttCand1Party", "AttCand2Name", "AttCand2Party", "SecCand1Name", "SecCand1Party", "SecCand2Name", "SecCand2Party", "HouseCand1Name_post", "HouseCand1Party_post", "HouseCand2Name_post", "HouseCand2Party_post", "HouseCand3Name_post", "HouseCand3Party_post")

CES_20_subset_vars <- c(
  "caseid", "inputzip_post", "votereg_f_post", "regzip_post", "commonweight", "commonpostweight", "vvweight", "vvweight_post", "inputstate", "inputstate_post", "cdid116", "cdid116_post", "gender", "educ", "birthyr", "cit1", "milstat_1", "milstat_3", "CC20_361", "region", "votereg", "employ", "union", "ownhome", "faminc_new", "hispanic", "CC20_401", "CC20_402a", "CC20_403", "CC20_410", "CC20_411", "CC20_365_voted", "CC20_411b", "CC20_365b_voted", "CC20_412", "CC20_413", "CC20_414a", "CC20_414b", "CC20_415c", "CC20_415d", "GovCand1Name_post", "GovCand1Party_post", "GovCand2Name_post", "GovCand2Party_post", "SenCand1Name_post", "SenCand1Party_post", "SenCand2Name_post", "SenCand2Party_post", "AttCand1Name", "AttCand1Party", "AttCand2Name", "AttCand2Party", "AttCand3Name", "AttCand3Party", "SecCand1Name", "SecCand1Party", "SecCand2Name", "SecCand2Party", "HouseCand1Name_post", "HouseCand1Party_post", "HouseCand2Name_post", "HouseCand2Party_post", "HouseCand3Name_post", "HouseCand3Party_post", "HouseCand4Name_post", "HouseCand4Party_post", "HouseCand5Name_post", "HouseCand5Party_post", "HouseCand6Name_post", "HouseCand6Party_post", "HouseCand7Name_post", "HouseCand7Party_post", "HouseCand8Name_post", "HouseCand8Party_post", "HouseCand9Name_post", "HouseCand9Party_post")

CES_22_subset_vars <- c(
"caseid", "inputzip_post", "votereg_f_post", "regzip_post", "commonweight", "commonpostweight", "inputstate", "inputstate_post", "cdid118", "cdid118_post", "gender4", "educ", "birthyr", "cit1", "milstat_1", "milstat_3", "CC22_361", "region", "votereg", "employ", "union", "ownhome", "faminc_new", "hispanic", "CC22_401", "CC22_402a", "CC22_403", "CC22_411", "CC22_365_voted", "CC22_411b", "CC22_365b_voted", "CC22_412", "CC22_413", "CC22_414a", "CC22_414b", "CC22_415c", "CC22_415d", "GovCand1Name_post", "GovCand1Party_post", "GovCand2Name_post", "GovCand2Party_post", "GovCand3Name_post", "GovCand3Party_post", "SenCand1Name_post", "SenCand1Party_post", "SenCand2Name_post", "SenCand2Party_post", "SenCand3Name_post", "SenCand3Party_post", "SenCand4Name_post", "SenCand4Party_post", "AttCand1Name", "AttCand1Party", "AttCand2Name", "AttCand2Party", "AttCand3Name", "AttCand3Party", "SecCand1Name", "SecCand1Party", "SecCand2Name", "SecCand2Party", "SecCand3Name", "SecCand3Party", "HouseCand1Name_post", "HouseCand1Party_post", "HouseCand2Name_post", "HouseCand2Party_post", "HouseCand3Name_post", "HouseCand3Party_post", "HouseCand4Name_post", "HouseCand4Party_post", "HouseCand5Name_post", "HouseCand5Party_post", "HouseCand6Name_post", "HouseCand6Party_post", "HouseCand7Name_post", "HouseCand7Party_post", "HouseCand8Name_post", "HouseCand8Party_post")

CES_06_raw_subset <- CES_06_raw[, CES_06_subset_vars]
CES_08_raw_subset <- CES_08_raw[, CES_08_subset_vars]
CES_10_raw_subset <- CES_10_raw[, CES_10_subset_vars]
CES_12_raw_subset <- CES_12_raw[, CES_12_subset_vars]
CES_14_raw_subset <- CES_14_raw[, CES_14_subset_vars]
CES_16_raw_subset <- CES_16_raw[, CES_16_subset_vars]
CES_18_raw_subset <- CES_18_raw[, CES_18_subset_vars]
CES_20_raw_subset <- CES_20_raw[, CES_20_subset_vars]
CES_22_raw_subset <- CES_22_raw[, CES_22_subset_vars]
```

Subset CPS to exclude respondents below 18 because the CES is limited to 18+
```{r}
# Define the years range
years <- seq(2006, 2022, by = 2)

# Iterate over the years
for (year in years) {
  # Extract the last two digits of the year
  year_short <- substr(year, 3, 4)
  
  # Define the variable names for the current year
  raw_df_name <- paste0("CPS_", year_short, "_raw")
  subset_vars <- intersect(colnames(get(raw_df_name)), cps_vars_all)

  # Subset the raw dataframe using the filtered variable list
  subset_df <- get(raw_df_name)[, subset_vars, drop = FALSE]
  
  # print any vars in cps_vars_all that are not in subset_vars
  print(paste("Missing vars for CES", year_short))
  print(setdiff(cps_vars_all, subset_vars))
  
  # Reorder the columns to match the order in cps_vars_all
  subset_df <- subset_df[, match(cps_vars_all, colnames(subset_df))]
  
  # Filter under 18
  subset_df <- subset_df %>%
    filter(AGE >= 18)
  
  # Assign the subset dataframe back to the global environment
  assign(paste0(raw_df_name, "_subset"), subset_df, envir = .GlobalEnv)
}

```

### Update CES/CPS data structures
Sometimes I make changes to one year individually, and other times I make changes to all years simultaneously. To keep things clean, below are a series of functions to make sure that each individual year in the global environment is synced with each year in the "list_all_years" object, which groups all years together for easier processing.
```{r}
# list_all_years contains a list of all CES and CPS datasets, organized by year. As changes are made to these datasets, update_list_all_years updates
# list_all_years with the current versions of each df in the global environment.
update_list_all_years <- function() {
  list_all_years <- list(
  list(CPS = CPS_06_rc_clean, CES = CES_06_rc_clean, year = 2006),
  list(CPS = CPS_08_rc_clean, CES = CES_08_rc_clean, year = 2008),
  list(CPS = CPS_10_rc_clean, CES = CES_10_rc_clean, year = 2010),
  list(CPS = CPS_12_rc_clean, CES = CES_12_rc_clean, year = 2012),
  list(CPS = CPS_14_rc_clean, CES = CES_14_rc_clean, year = 2014),
  list(CPS = CPS_16_rc_clean, CES = CES_16_rc_clean, year = 2016),
  list(CPS = CPS_18_rc_clean, CES = CES_18_rc_clean, year = 2018),
  list(CPS = CPS_20_rc_clean, CES = CES_20_rc_clean, year = 2020),
  list(CPS = CPS_22_rc_clean, CES = CES_22_rc_clean, year = 2022)
  )
  
  assign("list_all_years", list_all_years, envir = .GlobalEnv)
}

# This does the inverse: If I make changes to each df inside of list_all_years, this function pushes those changes to the global environment, so each individual
# year reflects any changes made inside of list_all_years.
push_list_all_years_to_env <- function() {
  for (entry in list_all_years) {
    year <- entry$year
    
    # Construct object names
    cps_name <- paste0("CPS_", substr(year, 3, 4), "_rc_clean")
    ces_name <- paste0("CES_", substr(year, 3, 4), "_rc_clean")
    
    # Assign to global environment
    assign(cps_name, entry$CPS, envir = .GlobalEnv)
    assign(ces_name, entry$CES, envir = .GlobalEnv)
  }
}


update_ces_rc_datasets <- function() {
  ces_rc_datasets <- setNames(
  list(CES_06_rc, CES_08_rc, CES_10_rc, CES_12_rc, CES_14_rc, CES_16_rc, CES_18_rc, CES_20_rc, CES_22_rc),
  c("2006", "2008", "2010", "2012", "2014", "2016", "2018", "2020", "2022")
)
  assign("ces_rc_datasets", ces_rc_datasets, envir = .GlobalEnv)
}
```

# Recoding CES and CPS
## Codebook recodings
Recode CES and CPS to have corresponding levels for comparable variables. Ensure that CODEBOOK.xlsm is in the code directory (same directory level as analysisHQ.Rmd)
```{r message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE, results='hide'}
apply_codebook_and_recode(6)
apply_codebook_and_recode(8)
apply_codebook_and_recode(10)
apply_codebook_and_recode(12)
apply_codebook_and_recode(14)
apply_codebook_and_recode(16)
apply_codebook_and_recode(18)
apply_codebook_and_recode(20)
apply_codebook_and_recode(22)
```

## Manual recodings
```{r}
make_state_to_region <- function() {
  region_mapping <- list(
    "Northeast" = c("CT", "ME", "MA", "NH", "RI", "VT", "NJ", "NY", "PA"),
    "Midwest" = c("IL", "IN", "MI", "OH", "WI", "IA", "KS", "MN", "MO", "NE", "ND", "SD"),
    "South" = c("DE", "DC", "FL", "GA", "MD", "NC", "SC", "VA", "WV", "AL", "KY", "MS", "TN", "AR", "LA", "OK", "TX"),
    "West" = c("AZ", "CO", "ID", "MT", "NV", "NM", "UT", "WY", "AK", "CA", "HI", "OR", "WA"))

  # Flatten the mapping into a named vector
  state_abbr <- unlist(region_mapping)
  regions <- rep(names(region_mapping), times = lengths(region_mapping))
  setNames(regions, state_abbr)
}

state_to_region <- make_state_to_region()
```


```{r warning=FALSE}
year_mapping <- c("2006" = 1, "2008" = 2, "2010" = 3, "2012" = 4, "2014" = 5, "2016" = 6, "2018" = 7, "2020" = 8, "2022" = 9)

# Apply age groups to CES data frames
CES_06_rc$AGE_GROUP_rc <- calculate_age_groups(2006 - CES_06_rc$v2020)
CES_08_rc$AGE_GROUP_rc <- calculate_age_groups(2008 - CES_08_rc$V207)
CES_10_rc$AGE_GROUP_rc <- calculate_age_groups(2010 - CES_10_rc$V207)
CES_12_rc$AGE_GROUP_rc <- calculate_age_groups(2012 - CES_12_rc$birthyr)
CES_14_rc$AGE_GROUP_rc <- calculate_age_groups(2014 - CES_14_rc$birthyr)
CES_16_rc$AGE_GROUP_rc <- calculate_age_groups(2016 - CES_16_rc$birthyr)
CES_18_rc$AGE_GROUP_rc <- calculate_age_groups(2018 - CES_18_rc$birthyr)
CES_20_rc$AGE_GROUP_rc <- calculate_age_groups(2020 - CES_20_rc$birthyr)
CES_22_rc$AGE_GROUP_rc <- calculate_age_groups(2022 - CES_22_rc$birthyr)

# Apply age groups to CPS data frames
CPS_06_rc$AGE_GROUP_rc <- calculate_age_groups(CPS_06_rc$AGE)
CPS_08_rc$AGE_GROUP_rc <- calculate_age_groups(CPS_08_rc$AGE)
CPS_10_rc$AGE_GROUP_rc <- calculate_age_groups(CPS_10_rc$AGE)
CPS_12_rc$AGE_GROUP_rc <- calculate_age_groups(CPS_12_rc$AGE)
CPS_14_rc$AGE_GROUP_rc <- calculate_age_groups(CPS_14_rc$AGE)
CPS_16_rc$AGE_GROUP_rc <- calculate_age_groups(CPS_16_rc$AGE)
CPS_18_rc$AGE_GROUP_rc <- calculate_age_groups(CPS_18_rc$AGE)
CPS_20_rc$AGE_GROUP_rc <- calculate_age_groups(CPS_20_rc$AGE)
CPS_22_rc$AGE_GROUP_rc <- calculate_age_groups(CPS_22_rc$AGE)


# Region
CES_06_rc$REGION_rc <- as.factor(state_to_region[CES_06_rc$v1002])
CES_08_rc$REGION_rc <- as.factor(state_to_region[fips(CES_08_rc$V206, to = "abbreviation")])
CES_10_rc$REGION_rc <- as.factor(state_to_region[fips(CES_10_rc$V206, to = "abbreviation")])
CES_12_rc$REGION_rc <- as.factor(state_to_region[fips(CES_12_rc$inputstate, to = "abbreviation")])
CES_14_rc$REGION_rc <- as.factor(state_to_region[fips(CES_14_rc$inputstate, to = "abbreviation")])
CES_16_rc$REGION_rc <- as.factor(state_to_region[fips(CES_16_rc$inputstate, to = "abbreviation")])
CES_18_rc$REGION_rc <- as.factor(state_to_region[fips(CES_18_rc$inputstate, to = "abbreviation")])
CES_20_rc$REGION_rc <- as.factor(state_to_region[fips(CES_20_rc$inputstate, to = "abbreviation")])
CES_22_rc$REGION_rc <- as.factor(state_to_region[fips(CES_22_rc$inputstate, to = "abbreviation")])

# Add pre- and post- questionnaire state
update_ces_rc_datasets()
add_location_vars(ces_rc_datasets, pre_post_location_vars)
update_ces_rc_datasets()


# Military Status in CPS
cps_rc_datasets <- list(CPS_06_rc, CPS_08_rc, CPS_10_rc, CPS_12_rc, CPS_14_rc, CPS_16_rc, CPS_18_rc, CPS_20_rc, CPS_22_rc)

for (i in seq_along(cps_rc_datasets)) {
  cps_rc_datasets[[i]]$CUR_MIL_rc <- as.factor(ifelse(
    cps_rc_datasets[[i]]$EMPSTAT == 1,
    "Serving",
    ifelse(cps_rc_datasets[[i]]$EMPSTAT == 0, NA, "Not serving")
  ))
  print(paste("CPS Current Military Done", names(year_mapping)[i]))
}

list2env(setNames(cps_rc_datasets, c("CPS_06_rc", "CPS_08_rc", "CPS_10_rc", "CPS_12_rc", "CPS_14_rc", "CPS_16_rc", "CPS_18_rc", "CPS_20_rc", "CPS_22_rc")), envir = .GlobalEnv)

party_mapping <- c("1" = "Democratic", "2" = "Republican", "3" = "Independent")

#In 2006, it always defaulted that first candidate was Democrat and second was Republican
CES_06_rc <- CES_06_rc %>%
  mutate(
    # Governor
    v5010 = party_mapping[as.character(v5010)],
    v5012 = party_mapping[as.character(v5012)],
    # US Senate
    v5006 = party_mapping[as.character(v5006)],
    v5008 = party_mapping[as.character(v5008)]
  )

# Recoding HOUSE_rc to be the corresponding party that each respondent voted for
update_ces_rc_datasets()
# Loop through each year and recode HOUSE_rc based on the candidate names available for that year
for (year in names(ces_rc_datasets)) {
  if (year %in% c("2006", "2008", "2010")) next
  
  # Recode the data
  recoded_data <- recode_house_rc(ces_rc_datasets[[year]], yrly_ces_house_candidate_names[[year]])
  
  # Assign the recoded data to its original name in the global environment
  assign(ces_rc_df_name_mapping[year], recoded_data, envir = .GlobalEnv)
}

# Add President names and party columns
CES_08_rc$PRES_DEM_CAND <- "OBAMA"
CES_08_rc$PRES_DEM_PARTY <- "Democratic"
CES_08_rc$PRES_REP_CAND <- "MCCAIN"
CES_08_rc$PRES_REP_PARTY <- "Republican"

CES_12_rc$PRES_DEM_CAND <- "OBAMA"
CES_12_rc$PRES_DEM_PARTY <- "Democratic"
CES_12_rc$PRES_REP_CAND <- "ROMNEY"
CES_12_rc$PRES_REP_PARTY <- "Republican"

CES_16_rc$PRES_DEM_CAND <- "CLINTON"
CES_16_rc$PRES_DEM_PARTY <- "Democratic"
CES_16_rc$PRES_REP_CAND <- "TRUMP"
CES_16_rc$PRES_REP_PARTY <- "Republican"

CES_20_rc$PRES_DEM_CAND <- "BIDEN"
CES_20_rc$PRES_DEM_PARTY <- "Democratic"
CES_20_rc$PRES_REP_CAND <- "TRUMP"
CES_20_rc$PRES_REP_PARTY <- "Republican"

# Clean up NAs (ie. make sure "NA", __NA__, "NA_char" are all treated as data type NA)
CES_06_rc_clean <- clean_NAs(CES_06_rc)
CPS_06_rc_clean <- clean_NAs(CPS_06_rc)

CES_08_rc_clean <- clean_NAs(CES_08_rc)
CPS_08_rc_clean <- clean_NAs(CPS_08_rc)

CES_10_rc_clean <- clean_NAs(CES_10_rc)
CPS_10_rc_clean <- clean_NAs(CPS_10_rc)

CES_12_rc_clean <- clean_NAs(CES_12_rc)
CPS_12_rc_clean <- clean_NAs(CPS_12_rc)

CES_14_rc_clean <- clean_NAs(CES_14_rc)
CPS_14_rc_clean <- clean_NAs(CPS_14_rc)

CES_16_rc_clean <- clean_NAs(CES_16_rc)
CPS_16_rc_clean <- clean_NAs(CPS_16_rc)

CES_18_rc_clean <- clean_NAs(CES_18_rc)
CPS_18_rc_clean <- clean_NAs(CPS_18_rc)

CES_20_rc_clean <- clean_NAs(CES_20_rc)
CPS_20_rc_clean <- clean_NAs(CPS_20_rc)

CES_22_rc_clean <- clean_NAs(CES_22_rc)
CPS_22_rc_clean <- clean_NAs(CPS_22_rc)

CES_06_rc_clean <- as.data.frame(CES_06_rc_clean)
CES_08_rc_clean <- as.data.frame(CES_08_rc_clean)
CES_10_rc_clean <- as.data.frame(CES_10_rc_clean)
CES_12_rc_clean <- as.data.frame(CES_12_rc_clean)
CES_14_rc_clean <- as.data.frame(CES_14_rc_clean)
CES_16_rc_clean <- as.data.frame(CES_16_rc_clean)
CES_18_rc_clean <- as.data.frame(CES_18_rc_clean)
CES_20_rc_clean <- as.data.frame(CES_20_rc_clean)
CES_22_rc_clean <- as.data.frame(CES_22_rc_clean)

update_list_all_years()
```

# Recode Party Vote
The codebook creates new columns called SENATOR_rc, GOV_rc, HOUSE_rc, etc., to reflect a respondent's vote for a candidate. From 2006 to 2010, the vote choices could be directly mapped to a party because the options were "Democrat," "Republican," and "Other." However, from 2012 - 2022, the CES changed the way it recorded candidate votes. Instead of using party names, votes were recorded for a particular candidate like "Cand1", "Cand2", etc. So now, each respondent's vote must be dynamically assigned a party based on the party of whichever candidate they voted for. The CES included additional variables for each candidate's party affiliation, such as "SenCand1Party", "GovCand2Party", etc. 
```{r}
#' Recode Candidate Vote Variables to Party Labels
#'
#' This function recodes candidate vote variables (e.g., `SENATOR_rc`, `GOV_rc`, `PRES_rc`, `HOUSE_rc`)
#' from codes like "Cand1", "Cand2", etc., into party labels ("Democrat", "Republican", or "Other")
#' based on candidate party mappings. It updates each CES dataframe in the global environment 
#' rather than modifying the `list_all_years` structure directly. Note that it skips 2006 - 2010
#' because these years were directly recoded using the CODBEOOK - they did not use the same Cand1, Cand2
#' structure that started in 2012. 
#' After running this function, use `push_list_all_years_to_env()` to reflect changes in global env.
#'
#' @param list_all_years A list of lists, where each inner list contains `CPS`, `CES`, and `year` elements.
#' @param yrly_ces_candidate_names A named list containing party variable mappings for each year and race 
#'                                 (Governor, Senate, President).
#' @param yrly_ces_house_candidate_names A named list containing party variable mappings specifically 
#'                                       for House races.
#'
#' @return Returns a list in same structure as list_all_years, with modified columns for CES in each year
#'
recode_cand_to_party <- function(list_all_years, yrly_ces_candidate_names, yrly_ces_house_candidate_names) {
  for (i in seq_along(list_all_years)) {
    year_entry <- list_all_years[[i]]
    year <- as.character(year_entry$year)

    # Skip early years
    if (as.numeric(year) < 2012) {
      cat("Skipping year:", year, "\n")
      next
    }

    cat("Processing year:", year, "\n")
    ces_data <- year_entry$CES

    # Candidate mappings
    general_map <- yrly_ces_candidate_names[[year]]
    house_map <- yrly_ces_house_candidate_names[[year]]

    # Race-to-variable mapping
    race_var_map <- list(
      "US Senate" = "SENATOR_rc",
      "Governor" = "GOV_rc",
      "US House" = "HOUSE_rc"
    )

    for (race_name in names(race_var_map)) {
      vote_var <- race_var_map[[race_name]]

      # Skip if the variable is not in the data
      if (!vote_var %in% names(ces_data)) next

      # Select correct party variable mapping
      if (race_name == "US House") {
        party_vars <- house_map
      } else {
        if (!race_name %in% names(general_map)) {
          stop(paste("No mapping for race", race_name, "in year", year))
        }
        party_vars <- general_map[[race_name]]
      }

      # Extract only party variable names
      party_lookup <- party_vars[grepl("Party", names(party_vars), ignore.case = TRUE)]
      cand_names <- sub(".*Cand ([0-9]+) Party.*", "Cand\\1", names(party_lookup))
      names(party_lookup) <- cand_names

      # Identify invalid candidate codes (excluding "Other")
      vote_codes <- na.omit(unique(ces_data[[vote_var]]))
      invalid_codes <- setdiff(vote_codes, c(names(party_lookup), "Other"))
      if (length(invalid_codes) > 0) {
        stop(paste("Year", year, "race", race_name, 
                   "contains unmapped candidate codes:", paste(invalid_codes, collapse = ", ")))
      }

      # Recode values using dplyr + case_when
      for (cand in names(party_lookup)) {
        party_col <- party_lookup[[cand]]

        if (!party_col %in% names(ces_data)) {
          stop(paste("Missing expected party column", party_col, "in year", year))
        }

        ces_data <- ces_data %>%
          mutate(
            !!vote_var := case_when(
              !!sym(vote_var) == cand &
                str_detect(!!sym(party_col), regex("democrat", ignore_case = TRUE)) ~ "Democrat",

              !!sym(vote_var) == cand &
                str_detect(!!sym(party_col), regex("republican", ignore_case = TRUE)) ~ "Republican",

              !!sym(vote_var) == cand &
                !is.na(!!sym(party_col)) &
                !str_detect(!!sym(party_col), regex("democrat|republican", ignore_case = TRUE)) ~ "Other",

              TRUE ~ !!sym(vote_var)
            )
          )
      }
    }

    # Update list with recoded CES data
    list_all_years[[i]]$CES <- ces_data

  }

  return(list_all_years)
}
```

Update list_all_years, run the recoding, then push changes from list_all_years back to global environment to keep list_all_years synced with each individual CES year in the global environment.
```{r}
update_list_all_years()
list_all_years <- recode_cand_to_party(
  list_all_years, 
  yrly_ces_candidate_names, 
  yrly_ces_house_candidate_names
)
push_list_all_years_to_env()
```

# Create Election Return Prop Tables
The raw election return files are loaded in the "election validation" section. The following code creates a series of "prop" tables for each election, which says what share of votes each candidate received in each election. 
```{r}
# US House
House_0622_clean_fixed <- recalculate_total_votes(House_0622, "statewide")
house_prop_table <- calculate_state_level_party_proportions(House_0622_clean_fixed) 
house_prop_table$Office <- "US House"

# US Senate
Senate_0622_clean_fixed <- recalculate_total_votes(Senate_0622, "statewide")
senate_cand_prop_table <- calculate_candidate_proportions(Senate_0622_clean_fixed) %>%
  mutate(office = "US Senate") %>%
  rename(
    Office = office,
    State = state,
    District = district,
    Year = year,
    Candidate = candidate_name,
    Cand_Num = cand_num,
    Party_Detailed = party_detailed,
    Party_Simplified = party_simplified,
    `Total Votes` = totalvotes,
    Proportion = proportion
  )

# Governor
Governor_0622_clean_fixed <- recalculate_total_votes(Governor_0622, "statewide")
governor_cand_prop_table <- calculate_candidate_proportions(Governor_0622_clean_fixed) %>%
  mutate(office = "Governor") %>%
  rename(
    Office = office,
    State = state,
    District = district,
    Year = year,
    Candidate = candidate_name,
    Cand_Num = cand_num,
    Party_Detailed = party_detailed,
    Party_Simplified = party_simplified,
    `Total Votes` = totalvotes,
    Proportion = proportion
  )

# President
President_0820_nums <- assign_president_candidate_numbers(President_0820) %>%
  filter(candidate %notin% c("OVER VOTE", "OVERVOTE", "OVERVOTES", "OVER VOTES"))
president_candid_prop_table <- calculate_candidate_proportions(President_0820_nums) %>%
  mutate(office = "President") %>%
  rename(
    Office = office,
    State = state,
    District = district,
    Year = year,
    Candidate = candidate_name,
    Cand_Num = cand_num,
    Party_Detailed = party_detailed,
    Party_Simplified = party_simplified,
    `Total Votes` = totalvotes,
    Proportion = proportion
  )

# State Senate
state_upper_prop_table <- make_bp_prop_table(State_senate_full) %>%
  mutate(Office = "State Senator") %>%   
  select(Office, everything())    

# State House
state_lower_prop_table <- make_bp_prop_table(State_house_full) %>%
  mutate(Office = "State Representative") %>%   
  select(Office, everything())    

# Attorney General
attorney_general_prop_table <- make_bp_prop_table(Attorney_general_full) %>%
  mutate(Office = "Attorney General") %>%   
  select(Office, everything()) 

# Secretary of State
secretary_of_state_prop_table <- make_bp_prop_table(Secretary_of_state_full) %>%
  mutate(Office = "Secretary of State") %>%   
  select(Office, everything()) 

# Merge all results
merged_prop_tables <- rbind(governor_cand_prop_table, senate_cand_prop_table, state_upper_prop_table, state_lower_prop_table, attorney_general_prop_table, secretary_of_state_prop_table, president_candid_prop_table)
```

Collapsed prop table version
```{r}
collapse_proportion_table <- function(df) {
  df %>%
    group_by(State, Year = as.numeric(Year), Office, Party_Simplified) %>%
    summarise(Proportion = sum(Proportion, na.rm = TRUE), .groups = "drop") %>%
    pivot_wider(
      names_from = Party_Simplified,
      values_from = Proportion,
      names_prefix = "",
      values_fill = 0
    ) %>%
    rename(
      DEM_Proportion = DEM,
      REP_Proportion = REP,
      OTHER_Proportion = OTHER
    ) %>%
    select(State, Year, Office, DEM_Proportion, OTHER_Proportion, REP_Proportion)
}

collapsed_merged_prop_table <- collapse_proportion_table(merged_prop_tables)
merged_prop_tables_combined <- rbind(collapsed_merged_prop_table, house_prop_table)
```

# Create ANESRake Targets
ANESRake requires that "targets" are created for each variable, which specify the expected distribution of that variable in the population for each level of that variable.
```{r}
# Some variables require special weighting variables. This dictionary specifies which weighting variable should be used for those special variables, otherwise
# the common weighting var is used. 
create_targets <- function(year_data_list) {
  cps_wtvar_dict <- c(
  "UNION_rc" = "EARNWT",
  "VOTED_rc" = "VOSUPPWT",
  "VOTEHOW_rc" = "VOSUPPWT",
  "VOTERES_rc" = "VOSUPPWT",
  "VOTEREG_rc" = "VOSUPPWT"
)
  
  # Create a list to store targets for each year
  all_targets <- list()
  
  # Loop through each year's data
  for (year_data in year_data_list) {
    cps_df <- year_data$CPS
    ces_df <- year_data$CES
    current_year <- year_data$year
    
    # Create a list of all recoded variables for CES data
    variables <- intersect(names(ces_df), names(cps_df))
    variables <- variables[!grepl("DUM|OVERTIME", variables)]
  
    # Create population (cps) numeric values list with level names
    targets <- list()
    for (var in variables) {
      # Determine the appropriate weight variable
      weight_var <- if (var %in% names(cps_wtvar_dict)) cps_wtvar_dict[var] else "WTFINL"
      
      # Calculate weighted proportions for each level using wpct
      weighted_proportions <- wpct(cps_df[[var]], weight = cps_df[[weight_var]], na.rm=TRUE)
      
      # Convert proportions to numeric values with level names
      numeric_values <- as.numeric(weighted_proportions)
      names(numeric_values) <- names(weighted_proportions)
      
      # Store numeric values in the list
      targets[[var]] <- numeric_values
    }
    
    # Append targets for the current year to the list of all targets
    target_name <- paste0(current_year)
    all_targets[[target_name]] <- targets
  }
  
  return(all_targets)
}
```

Update list_all_years, then create targets for each year for all variables that are present in both CES and CPS.
```{r}
update_list_all_years()
all_targets <- create_targets(list_all_years)

# This screw up the anesrake algo, because there are so few ppl in military that it rounds to 0 which throws an error. 
noMILorWKR_all_targets <- lapply(all_targets, function(sublist) {
  # Check if CUR_MIL_rc exists in the sublist, and if so, remove it
  sublist$CUR_MIL_rc <- NULL
  sublist$CLASSWKR_rc <- NULL
  sublist$VOTEREG_rc <- NULL
  return(sublist)
})
```


Function to run ANESRake weighting for each year
```{r}
# Function to convert user-input year to list index number
convert_year_to_index <- function(input_year) {
  return(year_mapping[as.character(input_year)])
}

run_weighting <- function(year_list, targets) {
  #browser()
  results_list <- list()
  for (year in year_list) {
    print(year)
    list_index_number <- convert_year_to_index(year)
    
    # Extract the required data for the specified year
    target_data <- targets[[as.character(year)]]
    # Excludes weighting on dummy variables and overtime variables
    target_data <- target_data[!grepl("_DUM|OVERTIME", names(target_data))]
    CES_data <- list_all_years[[list_index_number]]$CES
    caseid_col <- CES_data[, 1]
    
    outsave <-
      anesrake(target_data,
               CES_data,
               caseid = caseid_col,
               verbose = FALSE)
            
    # Store results in the list
    caseweights <-
      data.frame(cases = outsave$caseid, weights = outsave$weightvec)
    results_list[[paste0(year)]] <- list(caseweights = caseweights,
                                         outsave_summary = summary(outsave))
  }
   
  return(results_list)
}
```


```{r}
noMILorWKR_weighting_results <- run_weighting(c(2006, 2008, 2010, 2012, 2014, 2016, 2018, 2020, 2022), noMILorWKR_all_targets)
```


Add the new weight column to each year's df
```{r}
add_weights_to_df <- function(df, year, weighting_results) {
  # Extract weights and case IDs from the results for the specified year
  weights <- weighting_results[[as.character(year)]]$caseweights
  weights <- weights[order(weights$cases), ]  # Sort by case IDs
  
  # Merge weights with the dataframe
  merged_df <- merge(df, weights, by.x = 1, by.y = "cases", all.x = TRUE)  # Assuming case ID column is the first column
  
  # Rename the weights column
  colnames(merged_df)[ncol(merged_df)] <- "anesrake_weight"
  
  return(merged_df)
}
```


```{r}
CES_06_rc_clean <- add_weights_to_df(CES_06_rc_clean, 2006, noMILorWKR_weighting_results)
CES_08_rc_clean <- add_weights_to_df(CES_08_rc_clean, 2008, noMILorWKR_weighting_results)
CES_10_rc_clean <- add_weights_to_df(CES_10_rc_clean, 2010, noMILorWKR_weighting_results)
CES_12_rc_clean <- add_weights_to_df(CES_12_rc_clean, 2012, noMILorWKR_weighting_results)
CES_14_rc_clean <- add_weights_to_df(CES_14_rc_clean, 2014, noMILorWKR_weighting_results)
CES_16_rc_clean <- add_weights_to_df(CES_16_rc_clean, 2016, noMILorWKR_weighting_results)
CES_18_rc_clean <- add_weights_to_df(CES_18_rc_clean, 2018, noMILorWKR_weighting_results)
CES_20_rc_clean <- add_weights_to_df(CES_20_rc_clean, 2020, noMILorWKR_weighting_results)
CES_22_rc_clean <- add_weights_to_df(CES_22_rc_clean, 2022, noMILorWKR_weighting_results)
update_list_all_years()
```

# Election Accuracies
```{r}
# Create template accuracy df
create_empty_result_df <- function() {
  data.frame(
    Year = numeric(),
    Race = character(),
    State = character(),
    CES_Candidate = character(),
    True_Candidate = character(),
    CES_Party = character(),
    True_Party = character(),
    Actual_Percent = numeric(),
    CES_Unweighted_Percent = numeric(),
    CES_Weighted_Percent = numeric(),
    ANESRake_Weighted_Percent = numeric(),
    Diff_Unweighted_CES_Actual = numeric(),
    Diff_Weighted_CES_Actual = numeric(),
    Diff_ANESRake_Actual = numeric(),
    n_respondents = numeric(),
    stringsAsFactors = FALSE
  )
}

# Weighting vars for each year
yearly_ces_wt_vars <- list(
  "2006" = c("v1001", "anesrake_weight"),
  "2008" = c("V201", "anesrake_weight"),
  "2010" = c("V101", "anesrake_weight"),
  "2012" = c("V103", "anesrake_weight"),
  "2014" = c("weight", "anesrake_weight"),
  "2016" = c("commonweight_post", "commonweight_vv", "commonweight", "anesrake_weight"),
  "2018" = c("commonpostweight", "commonweight","anesrake_weight"),
  "2020" = c("commonpostweight", "commonweight",  "anesrake_weight"),
  "2022" = c("commonpostweight", "commonweight", "anesrake_weight"))
```

Compute Election Accuracy Function
```{r}
create_election_accuracy_tbl <- function(yearly_ces_wt_vars,
                                         election_results_df,
                                         year_data_list,
                                         NC_flag_df) {
  browser()
  
  # map CES column names to the exact Office labels in election_results_df$Office
  race_map <- c(
    HOUSE_rc                 = "US House",
    SENATE_rc                = "US Senate",
    PRES_rc                  = "President",
    GOV_rc                   = "Governor",
    SECSTATE_rc              = "Secretary of State",
    AG_rc                    = "Attorney General",
    ST_REP_rc                = "State Representative",
    ST_SENATOR_rc            = "State Senator"
  )
  
  result_list <- list()
  
  for (year_data in year_data_list) {
    current_year <- year_data$year
    ces_df <- year_data$CES
    
    # drop NC cases in 2020 if flagged
    if (current_year == 2020) {
      ces_df <- ces_df %>%
        filter(!(caseid %in% NC_flag_df$caseid))
    }
    
    # restrict to results for this year
    year_elec <- election_results_df %>% filter(Year == current_year)
    
    # figure out which CES columns we actually have this year
    available_races <- intersect(names(ces_df), names(race_map))
    result_df <- create_empty_result_df()
    
    for (race_col in available_races) {
      office_label <- race_map[[race_col]]
      
      for (state in unique(na.omit(ces_df$POST_STATE_rc))) {
            # SKIPâ€LOGIC: bail if this year/race/state is flagged
        skip_row <- skip_conditions %>%
          filter(State == state,
                 Year  == current_year,
                 Race  == race_col,       # or use office_label if your skip_conditions$Race is the full Office name
                 `Skip?` == TRUE)
        if (nrow(skip_row) > 0) next
  
        state_survey <- ces_df %>% filter(POST_STATE_rc == state)
        n_resp <- sum(!is.na(state_survey[[race_col]]))
        if (n_resp == 0) next
        
        # find the matching election returns
        state_returns <- year_elec %>%
          filter(State == state, Office == office_label)
        if (nrow(state_returns) == 0) {
          stop(glue::glue("No election results for {office_label}, {state}, {current_year}"))
        }
        
        # compute weighted proportions
        wt_var <- yearly_ces_wt_vars[[ as.character(current_year) ]][1]
        ces_wt   <- wpct(state_survey[[race_col]], weight = state_survey[[wt_var]], na.rm = TRUE)
        ces_unwt <- wpct(state_survey[[race_col]], na.rm = TRUE)
        anes_wt  <- wpct(state_survey[[race_col]], weight = state_survey$anesrake_weight, na.rm = TRUE)
        
        # ensure all three parties
        for (lvl in c("Democrat","Republican","Other")) {
          if (lvl %notin% names(ces_wt))   ces_wt[lvl]   <- 0
          if (lvl %notin% names(ces_unwt)) ces_unwt[lvl] <- 0
          if (lvl %notin% names(anes_wt))  anes_wt[lvl]  <- 0
        }
        ces_wt   <- ces_wt[c("Democrat","Republican","Other")]
        ces_unwt <- ces_unwt[c("Democrat","Republican","Other")]
        anes_wt  <- anes_wt[c("Democrat","Republican","Other")]
        
        # true proportions
        true_vec <- c(
          Democrat  = state_returns$DEM_Proportion,
          Republican= state_returns$REP_Proportion,
          Other     = state_returns$OTHER_Proportion
        )
        
        # compute diffs
        diff_ces   <- ces_wt   - true_vec
        diff_unwt  <- ces_unwt - true_vec
        diff_anes  <- anes_wt  - true_vec
        
        # stack into rows
        for (party in names(true_vec)) {
          result_df <- bind_rows(
            result_df,
            tibble(
              Year                         = current_year,
              Race                         = office_label,
              State                        = state,
              CES_Candidate                = "Grouped Candidates",
              True_Candidate               = "Grouped Candidates",
              CES_Party                    = party,
              True_Party                   = party,
              Actual_Percent               = true_vec[party] * 100,
              CES_Unweighted_Percent       = ces_unwt[party] * 100,
              CES_Weighted_Percent         = ces_wt[party]   * 100,
              ANESRake_Weighted_Percent    = anes_wt[party]  * 100,
              Diff_Unweighted_CES_Actual   = diff_unwt[party] * 100,
              Diff_Weighted_CES_Actual     = diff_ces[party]   * 100,
              Diff_ANESRake_Actual         = diff_anes[party]  * 100,
              n_respondents                = n_resp
            )
          )
        }
      }
    }
    
    result_list[[as.character(current_year)]] <- result_df
  }
  
  bind_rows(result_list)
}

```


```{r}
accuracy_tables <- create_election_accuracy_tbl(
  yearly_ces_wt_vars,
  merged_prop_tables_combined,
  list_all_years,
  NC_flag_df
)
```






































```{r}
# Extract the recoded and original data
ces_after <- list_all_years[[which(sapply(list_all_years, function(x) x$year == 2022))]]$CES
ces_before <- CES_22_rc  # assuming this is your original (unrecoded) version

# Identify all party columns
house_party_cols <- grep("^SenCand[0-9]+Party_post$", names(ces_before), value = TRUE)

# Build inspection dataframe
inspect_df <- data.frame(
  Var_rc_after = ces_after$SENATOR_rc,
  Var_rc_before = ces_before$SENATOR_rc
)

# Add all HouseCandXParty_post columns from original data
inspect_df <- cbind(inspect_df, ces_before[, house_party_cols])

```


```{r}
search_variable_labels <- function(df, pattern) {
  matches <- lapply(names(df), function(varname) {
    label <- attr(df[[varname]], "label")
    if (!is.null(label) && grepl(pattern, label, ignore.case = TRUE)) {
      return(data.frame(
        Variable = varname,
        Label = label,
        stringsAsFactors = FALSE
      ))
    } else {
      return(NULL)
    }
  })
  # Combine results into a single data frame
  result <- do.call(rbind, matches)
  return(result)
}

search_variable_labels(CES_14_raw, "SenCand4")

```


