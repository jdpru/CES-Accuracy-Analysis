---
title: "analysisHQ"
author: "JD Pruett"
date: "2025-04-04"
output: html_document
---

# Environment Setup --------------------------------------
```{r setup, include=FALSE}
# knitr::opts_knit$set(root.dir = '/path/to/your/CES Accuracy Analysis')
knitr::opts_knit$set(root.dir = '/Users/jdpruett/Desktop/CES Accuracy Analysis')
```

```{r}
# Load functions and structures from other utility scripts
source("code/utilities/recoding_utilities.R")
source("code/utilities/data_structures.R")
source("code/utilities/election_return_utilities.R")
source("code/utilities/accuracy_utilities.R")
source("code/utilities/accuracy_utilities_refactored.R")
```

```{r, echo=False, warnings=FALSE, message=FALSE}
# create notin operator
`%notin%` <- Negate(`%in%`)

# Packages & working directory
pckgs <- c("haven", "readxl", "ipumsr", "here", "dplyr", "cdlTools", "anesrake", "writexl", "tidyverse", "rlang", "tibble", "naniar", "weights", "lubridate", "openxlsx", "cpsR", "purrr", "progress", "tidycensus", "humaniformat", "stringdist", "glue", "stringi")

## Uncomment this to download all necessary packages
# if (any(pckgs %notin% rownames(installed.packages())==TRUE)){
# install.packages(pckgs, repos = c(CRAN = "http://cloud.r-project.org"))}

invisible(sapply(pckgs, FUN = require, character.only = TRUE))

# current project root as identified by {here}
set_here()
```

# Read-in Data ----------------------------------------------
## CES Datasets
```{r}
CES_06_raw <- read_dta(here("data/CES Data/cces_2006_common.dta"))
CES_08_raw <- read_dta(here("data/CES Data/cces_2008_common.dta"))
CES_10_raw <- read_dta(here("data/CES Data/cces_2010_common_validated.dta"))
CES_12_raw <- read_dta(here("data/CES Data/commoncontent2012.dta"))
CES_14_raw <- read_dta(here("data/CES Data/CCES14_Common_Content_Validated.dta"))
CES_16_raw <- read_dta(here("data/CES Data/CCES16_Common_OUTPUT_Feb2018_VV.dta"))
CES_18_raw <- read_dta(here("data/CES Data/cces18_common_vv.dta"))
CES_20_raw <- read_dta(here("data/CES Data/CES20_Common_OUTPUT_vv.dta"))
CES_22_raw <- read_dta(here("data/CES Data/CES_2022_Common_Output.dta"))
```


## Election Return Datasets
### National Elections
```{r}
# Governor, U.S. Senate, President
Governor_0622 <- read_excel("data/Benchmarks/Election Returns/Governor_0622_clean_fixed.xlsx")
Senate_0622 <- read_excel("data/Benchmarks/Election Returns/Senate_0622_clean_fixed.xlsx")
President_0820 <- read_excel("data/Benchmarks/Election Returns/[FIN-FIX] President 2008-2020 clean fixed.xlsx")

# U.S. House
house_data_path <- "data/Benchmarks/Election Returns/[FIN-FIX] House 2006-2022 clean fixed.xlsx"
house_sheet_names <- excel_sheets(house_data_path)
house_sheet_names <- house_sheet_names[house_sheet_names != "Sources"]
House_0622 <- house_sheet_names %>%
  lapply(function(sheet) {
    data <- read_excel(path = house_data_path, sheet = sheet)
    data$state <- toupper(data$state)
    return(data)
  }) %>%
  bind_rows()

House_0622 <- House_0622 %>%
  mutate(party_simplified = case_when(
    party_detailed %in% c("DEM", "ADDITIONAL (D)", "ADDITIONAL(D)", "DNL", "DEMOCRATIC-FARMER-LABOR", "DEMOCRATIC") ~ "DEM",
    party_detailed %in% c("ADDITIONAL (R)", "ADDITIONAL(R)") ~ "REP",
    TRUE ~ party_simplified
  ))
```

### State Elections
```{r warning=FALSE}
# State-level elections master file
State_race_master_table <- read_excel("data/Benchmarks/Election Returns/[FIN-FIX] Historical election results data (2006 - 2023) clean fixed.xlsx")

State_race_master_table$`Election date` <- as.POSIXct(format(State_race_master_table$`Election date`, "%Y-%m-%d"))

# Parsing state-level master file into individual elections
## State senate
State_senate_full <- State_race_master_table[grepl("\\b(senate|senator|SS|SD|KYSENATOR)\\b", State_race_master_table[["Office/district"]], ignore.case = TRUE), ]

# State representative
State_house_full <- State_race_master_table[grepl("\\b(house|assembly|representative|partyresentative|State Rep.|SR|HD|assemblymember|KYREPRESENTATIVE|StateRepresentative|HouseDistrict)\\b|State Rep\\.", State_race_master_table[["Office/district"]], ignore.case = TRUE), ]

# Attorney general
Attorney_general_full <- State_race_master_table[grepl("Attorney", State_race_master_table[["Office/district"]], ignore.case = TRUE), ]

# Secretary of state
Secretary_of_state_full <- State_race_master_table[grepl("Secretary|Secratary", State_race_master_table[["Office/district"]], ignore.case = TRUE), ]
```

### Turnout
```{r}
turnout_national <- read_excel("data/Benchmarks/VAP_Turnout_Rates.xlsx", sheet="National")
turnout_statewide <- read_excel("data/Benchmarks/VAP_Turnout_Rates.xlsx", 
                                sheet = "Statewide", 
                                skip = 1, 
                                .name_repair = "unique_quiet") %>% 
  select(1:11) %>%
  slice(-n()) %>%
  mutate(State = toupper(State))
```

### State Populations
```{r}
state_populations <- read_excel("data/Benchmarks/Historical_State_Population_by_Year.xlsx")
```

### Misc.
```{r}
# CES assigned some respondents to incorrect congressional district in 2020
NC_flag_df <- read.csv("data/misc/NC_responents_incorrect_CD.csv") %>%
  filter(cd_change_flag_post == 1)

# This is a list of all the races that should be skipped because they were asked about in the CES but did not actually occur
skip_conditions <- read.xlsx("data/misc/skip_conditions_final.xlsx")
```

## CPS Datasets
```{r}
# Set IPUMS API Key (specific to user, free to acquire on IPUMS site)
USER_IPUMS_API_KEY = "59cba10d8a5da536fc06b59dd33fd321a4eb480fa8fe8ad46c9d0d3e"
set_ipums_api_key(USER_IPUMS_API_KEY, save = TRUE, overwrite = TRUE)
```

### Prep monthly sample codes and variables
This is necessary to use the IPUMS API to download CPS data.
```{r}
# All
cps_vars_all <- c("WTFINL", "EARNWT", "VOSUPPWT", "STATEFIP", "SEX", "EDUC", "AGE", "CITIZEN", "HISPAN", "OCC", "VETSTAT", "REGION", "EMPSTAT", "CLASSWKR", "UNION", "FAMINC", "VOTERES", "VOREG", "VOTED", "VOWHYNOT", "VOTEHOW")

# 2006
cps_sample_2006 = c('cps2006_01s', 'cps2006_02b', 'cps2006_03b', 'cps2006_04b', 'cps2006_05s', 'cps2006_06s', 'cps2006_07b', 'cps2006_08s', 'cps2006_09s', 'cps2006_10s', 'cps2006_11s', 'cps2006_12s')
# 2008
cps_sample_2008 = c('cps2008_01s', 'cps2008_02b', 'cps2008_03b', 'cps2008_04b', 'cps2008_05s', 'cps2008_06s', 'cps2008_07b', 'cps2008_08s', 'cps2008_09s', 'cps2008_10s', 'cps2008_11s', 'cps2008_12s')
# 2010
cps_sample_2010 = c('cps2010_01s', 'cps2010_02b', 'cps2010_03b', 'cps2010_04b','cps2010_05s', 'cps2010_06s','cps2010_07s', 'cps2010_08s', 'cps2010_09s', 'cps2010_10s', 'cps2010_11s', 'cps2010_12s')
# 2012
cps_sample_2012 = c('cps2012_01s', 'cps2012_02b', 'cps2012_03b', 'cps2012_04b', 'cps2012_05s', 'cps2012_06s', 'cps2012_07s', 'cps2012_08s', 'cps2012_09s', 'cps2012_10s', 'cps2012_11s', 'cps2012_12s')
# 2014
cps_sample_2014 = c('cps2014_01s', 'cps2014_02s', 'cps2014_03b', 'cps2014_04b', 'cps2014_05b', 'cps2014_06s', 'cps2014_07s', 'cps2014_08s', 'cps2014_09s', 'cps2014_10s', 'cps2014_11s', 'cps2014_12s')
# 2016
cps_sample_2016 = c('cps2016_01s', 'cps2016_02s', 'cps2016_03b', 'cps2016_04b', 'cps2016_05b', 'cps2016_06s', 'cps2016_07b', 'cps2016_08s', 'cps2016_09s', 'cps2016_10s', 'cps2016_11s', 'cps2016_12s')
# 2018
cps_sample_2018 = c('cps2018_01s', 'cps2018_02s', 'cps2018_03b', 'cps2018_04b', 'cps2018_05s', 'cps2018_06s', 'cps2018_07s', 'cps2018_08s', 'cps2018_09s', 'cps2018_10s', 'cps2018_11s', 'cps2018_12s')
# 2020
cps_sample_2020 = c('cps2020_01s', 'cps2020_02s', 'cps2020_03b', 'cps2020_04b', 'cps2020_05b', 'cps2020_06s', 'cps2020_07b', 'cps2020_08s', 'cps2020_09b', 'cps2020_10s', 'cps2020_11s', 'cps2020_12s')
# 2022
cps_sample_2022 = c('cps2022_01s', 'cps2022_02s', 'cps2022_03b', 'cps2022_04s', 'cps2022_05s', 'cps2022_06s', 'cps2022_07s', 'cps2022_08s', 'cps2022_09s', 'cps2022_10s', 'cps2022_11s', 'cps2022_12s')

```

### Read in CPS datasets to global environment
Note this creates xml (metadata) and .dat.giz (compressed raw data) files in the data/IPUMS CPS Artifacts subdirectory
```{r}
extract_codes <- list()

for (year in seq(2006, 2022, by = 2)) {
  suffix <- substr(year, 3, 4)
  extract_name <- paste("CPS Extract for", year)
  cps_sample_var <- paste("cps_sample", year, sep = "_")
  df_name <- paste("CPS", suffix, "raw", sep = "_")

  extract_code <- paste0(
    "  define_extract_micro(\n",
    "    collection = \"cps\",\n",
    "    description = \"", extract_name, "\",\n",
    "    samples = ", cps_sample_var, ",\n",
    "    variables = cps_vars_all) %>%\n",
    "  submit_extract() %>%\n",
    "  wait_for_extract() %>%\n",
    "  download_extract(download_dir = \"data/IPUMS CPS Artifacts\") %>%\n",
    "  read_ipums_micro()"
  )

  extract_codes[[df_name]] <- extract_code
}

for (df_name in names(extract_codes)) {
  assign(df_name, eval(parse(text = extract_codes[[df_name]])), envir = .GlobalEnv)
}
```



## Subset datasets --------------
Subset CES to only include relevant variables
```{r}
CES_06_subset_vars <- c(
  "v1000", "v1001", "v1002", "v1003", "v1004", "v2004", "v2018", "v2020", "v3081", "v3083", "v1006", "v2030", "v2073", "v2082", "v2033", "v2032", "v3004", "v4004", "v4006", "v4005", "v4014", "v4015", "v4013", "v4017", "v4018", "v4019", "v4020", "v4021", "v5009", "v5010", "v5011", "v5012", "v5005", "v5006", "v5007", "v5008", "v5001", "v5002", "v5003", "v5004")

CES_08_subset_vars <- c(
  "V100", "V201", "V206", "V207", "V208", "V250", "V251", "V202", "V205", "V204", "V213", "V252", "V253", "V258", "V257", "V247", "V259", "V264", "V501", "V502", "V553", "V555", "V601", "V602", "V603", "V612", "V653", "V655", "V657", "V672", "CC328_1", "CC328_3", "CC334", "CC410", "CC411", "CC411b", "CC412", "CC413", "CC414_2", "CC414_1", "V209", "CC329", "CC333", "V246", "V203", "CC403", "CC405", "CC404", "CC326b", "CC337", "CC337S2", "CC340", "CC338", "V618", "V619")

CES_10_subset_vars <- c(
  "V100", "V101", "V202_post", "V204_post", "V205_post", "V206", "V206_post", "V207", "V208", "V213", "V252", "V254", "V276", "V276_post", "V539_post", "V564_post", "V567_post", "V548_post", "V551_post", "V533_post", "V536_post", "V545_post", "V554_post", "V556_post", "V570_post", "V572_post","V574_post", "V576_post", "CC351", "V209", "V264", "V250", "V246", "V290", "CC401", "V203", "CC403", "CC402a", "CC410a", "CC410b", "CC412", "CC411", "CC413a", "CC413b", "CC413c", "CC413d")

CES_12_subset_vars <- c(
  "V101", "V103", "inputzip", "votereg_f", "regzip", "inputstate", "inputstate_post", "cdid113", "cdid113_post", "gender", "educ", "birthyr", "milstat_1", "milstat_3", "CC351", "votereg", "employ", "employercat", "union", "ownhome", "faminc",
  "hispanic", "CC401", "CC402a", "CC403", "CC410a", "CC410b", "CC355", "CC412", "CC411", "CC413a", "CC413b", "CC413c", "CC413d", "GovCand1Name_post", "GovCand1Party_post", "GovCand2Name_post", "GovCand2Party_post", "SenCand1Name_post", "SenCand1Party_post", "SenCand2Name_post", "SenCand2Party_post", "SenCand3Name_post", "SenCand3Party_post", "HouseCand1Name_post", "HouseCand1Party_post", "HouseCand2Name_post", "HouseCand2Party_post", "HouseCand3Name_post", "HouseCand3Party_post")


CES_14_subset_vars <- c(
  "V101", "weight", "inputzip_post", "votereg_f_post", "regzip_post", "inputstate", "inputstate_post", "cdid", "cdid_post", "gender", "educ", "birthyr", "milstat_1", "milstat_3", "CC351", 
  "votereg", "employ", "union", "ownhome", "faminc",
  "hispanic", "CC401", "CC402a", "CC403", "CC410b", "CC355x", "CC412", "CC411", "CC413a", "CC413b", "CC413c", "CC413d", "GovCand1Name_post", "GovCand1Party_post", "GovCand2Name_post", "GovCand2Party_post", "SenCand1Name_post", "SenCand1Party_post", "SenCand2Name_post", "SenCand2Party_post", "SenCand3Name_post", "SenCand3Party_post", "HouseCand1Name_post", "HouseCand1Party_post", "HouseCand2Name_post", "HouseCand2Party_post", "HouseCand3Name_post", "HouseCand3Party_post")

CES_16_subset_vars <- c(
  "V101", "inputzip_post", "votereg_f_post", "regzip_post", "commonweight_vv", "commonweight_vv_post", "commonweight_vv_lgbt", "commonweight", "commonweight_post", "inputstate", "inputstate_post", "cdid115", "cdid115_post", "gender", "educ", "birthyr", "milstat_1", "milstat_3", "CC16_361", "votereg", "employ", "union", "ownhome", "faminc", "hispanic", "CC16_401", "CC16_402a", "CC16_410a", "CC16_403", "CC16_410b", "CC16_412", "CC16_411", "CC16_413a", "CC16_413b", "CC16_413c", "CC16_413d", "GovCand1Name_post", "GovCand1Party_post", "GovCand2Name_post", "GovCand2Party_post", "GovCand3Name_post", "GovCand3Party_post", "SenCand1Name_post", "SenCand1Party_post", "SenCand2Name_post", "SenCand2Party_post", "SenCand3Name_post", "SenCand3Party_post", "SenCand4Name_post", "SenCand4Party_post", "HouseCand1Name_post", "HouseCand1Party_post", "HouseCand2Name_post", "HouseCand2Party_post", "HouseCand3Name_post", "HouseCand3Party_post", "HouseCand4Name_post", "HouseCand4Party_post", "HouseCand5Name_post", "HouseCand5Party_post", "HouseCand6Name_post", "HouseCand6Party_post", "HouseCand7Name_post", "HouseCand7Party_post", "HouseCand8Name_post", "HouseCand8Party_post", "HouseCand9Name_post", "HouseCand9Party_post", "HouseCand10Name_post", "HouseCand10Party_post", "HouseCand11Name_post", "HouseCand11Party_post")

CES_18_subset_vars <- c(
  "caseid", "inputzip_post", "votereg_f_post", "regzip_post", "commonweight", "commonpostweight", "vvweight", "vvweight_post", "inputstate", "inputstate_post", "cdid116", "cdid116_post", "gender", "educ", "birthyr", "cit1", "milstat_1", "milstat_3", "region", "votereg", "employ", "union", "ownhome", "faminc_new", "hispanic", "CC18_401", "CC18_402a", "CC18_403", "CC18_410b", "CC18_410bx", "CC18_412", "CC18_353x", "CC18_411", "CC18_352x", "CC18_420a", "CC18_420b", "CC18_420c", "CC18_413c", "CC18_413d", "GovCand1Name_post", "GovCand1Party_post", "GovCand2Name_post", "GovCand2Party_post", "GovCand3Name_post", "GovCand3Party_post", "SenCand1Name_post", "SenCand1Party_post", "SenCand2Name_post", "SenCand2Party_post", "SenCand3Name_post", "SenCand3Party_post", "AttCand1Name", "AttCand1Party", "AttCand2Name", "AttCand2Party", "SecCand1Name", "SecCand1Party", "SecCand2Name", "SecCand2Party", "HouseCand1Name_post", "HouseCand1Party_post", "HouseCand2Name_post", "HouseCand2Party_post", "HouseCand3Name_post", "HouseCand3Party_post", "HouseCand4Name_post", "HouseCand4Party_post", "HouseCand5Name_post", "HouseCand5Party_post", "HouseCand6Name_post", "HouseCand6Party_post", "HouseCand7Name_post", "HouseCand7Party_post")


CES_20_subset_vars <- c(
  "caseid", "inputzip_post", "votereg_f_post", "regzip_post", "commonweight", "commonpostweight", "vvweight", "vvweight_post", "inputstate", "inputstate_post", "cdid116", "cdid116_post", "gender", "educ", "birthyr", "cit1", "milstat_1", "milstat_3", "CC20_361", "region", "votereg", "employ", "union", "ownhome", "faminc_new", "hispanic", "CC20_401", "CC20_402a", "CC20_403", "CC20_410", "CC20_411", "CC20_365_voted", "CC20_411b", "CC20_365b_voted", "CC20_412", "CC20_413", "CC20_414a", "CC20_414b", "CC20_415c", "CC20_415d", "GovCand1Name_post", "GovCand1Party_post", "GovCand2Name_post", "GovCand2Party_post", "SenCand1Name_post", "SenCand1Party_post", "SenCand2Name_post", "SenCand2Party_post", "AttCand1Name", "AttCand1Party", "AttCand2Name", "AttCand2Party", "AttCand3Name", "AttCand3Party", "SecCand1Name", "SecCand1Party", "SecCand2Name", "SecCand2Party", "SecCand3Name", "SecCand3Party", "HouseCand1Name_post", "HouseCand1Party_post", "HouseCand2Name_post", "HouseCand2Party_post", "HouseCand3Name_post", "HouseCand3Party_post", "HouseCand4Name_post", "HouseCand4Party_post", "HouseCand5Name_post", "HouseCand5Party_post", "HouseCand6Name_post", "HouseCand6Party_post", "HouseCand7Name_post", "HouseCand7Party_post", "HouseCand8Name_post", "HouseCand8Party_post", "HouseCand9Name_post", "HouseCand9Party_post")

CES_22_subset_vars <- c(
"caseid", "inputzip_post", "votereg_f_post", "regzip_post", "commonweight", "commonpostweight", "inputstate", "inputstate_post", "cdid118", "cdid118_post", "gender4", "educ", "birthyr", "cit1", "milstat_1", "milstat_3", "CC22_361", "region", "votereg", "employ", "union", "ownhome", "faminc_new", "hispanic", "CC22_401", "CC22_402a", "CC22_403", "CC22_411", "CC22_365_voted", "CC22_411b", "CC22_365b_voted", "CC22_412", "CC22_413", "CC22_414a", "CC22_414b", "CC22_415c", "CC22_415d", "GovCand1Name_post", "GovCand1Party_post", "GovCand2Name_post", "GovCand2Party_post", "GovCand3Name_post", "GovCand3Party_post", "SenCand1Name_post", "SenCand1Party_post", "SenCand2Name_post", "SenCand2Party_post", "SenCand3Name_post", "SenCand3Party_post", "SenCand4Name_post", "SenCand4Party_post", "AttCand1Name", "AttCand1Party", "AttCand2Name", "AttCand2Party", "AttCand3Name", "AttCand3Party", "SecCand1Name", "SecCand1Party", "SecCand2Name", "SecCand2Party", "SecCand3Name", "SecCand3Party", "HouseCand1Name_post", "HouseCand1Party_post", "HouseCand2Name_post", "HouseCand2Party_post", "HouseCand3Name_post", "HouseCand3Party_post", "HouseCand4Name_post", "HouseCand4Party_post", "HouseCand5Name_post", "HouseCand5Party_post", "HouseCand6Name_post", "HouseCand6Party_post", "HouseCand7Name_post", "HouseCand7Party_post", "HouseCand8Name_post", "HouseCand8Party_post")

CES_06_raw_subset <- CES_06_raw[, CES_06_subset_vars]
CES_08_raw_subset <- CES_08_raw[, CES_08_subset_vars]
CES_10_raw_subset <- CES_10_raw[, CES_10_subset_vars]
CES_12_raw_subset <- CES_12_raw[, CES_12_subset_vars]
CES_14_raw_subset <- CES_14_raw[, CES_14_subset_vars]
CES_16_raw_subset <- CES_16_raw[, CES_16_subset_vars]
CES_18_raw_subset <- CES_18_raw[, CES_18_subset_vars]
CES_20_raw_subset <- CES_20_raw[, CES_20_subset_vars]
CES_22_raw_subset <- CES_22_raw[, CES_22_subset_vars]
```

Subset CPS to exclude respondents below 18 because the CES is limited to 18+
```{r}
# Define the years range
years <- seq(2006, 2022, by = 2)

# Iterate over the years
for (year in years) {
  # Extract the last two digits of the year
  year_short <- substr(year, 3, 4)
  
  # Define the variable names for the current year
  raw_df_name <- paste0("CPS_", year_short, "_raw")
  subset_vars <- intersect(colnames(get(raw_df_name)), cps_vars_all)

  # Subset the raw dataframe using the filtered variable list
  subset_df <- get(raw_df_name)[, subset_vars, drop = FALSE]
  
  # print any vars in cps_vars_all that are not in subset_vars
  print(paste("Missing vars for CES (0 expected)", year_short))
  print(setdiff(cps_vars_all, subset_vars))
  
  # Reorder the columns to match the order in cps_vars_all
  subset_df <- subset_df[, match(cps_vars_all, colnames(subset_df))]
  
  # Filter under 18
  subset_df <- subset_df %>%
    filter(AGE >= 18)
  
  # Assign the subset dataframe back to the global environment
  assign(paste0(raw_df_name, "_subset"), subset_df, envir = .GlobalEnv)
}

```

### Update CES/CPS data structures
Sometimes I make changes to one year individually, and other times I make changes to all years simultaneously. To keep things clean, below are a series of functions to make sure that each individual year in the global environment is synced with each year in the "list_all_years" object, which groups all years together for easier processing.
```{r}
# list_all_years contains a list of all CES and CPS datasets, organized by year. As changes are made to these datasets, update_list_all_years updates list_all_years with the current versions of each df in the global environment.
update_list_all_years <- function() {
  list_all_years <- list(
  list(CPS = CPS_06_rc_clean, CES = CES_06_rc_clean, year = 2006),
  list(CPS = CPS_08_rc_clean, CES = CES_08_rc_clean, year = 2008),
  list(CPS = CPS_10_rc_clean, CES = CES_10_rc_clean, year = 2010),
  list(CPS = CPS_12_rc_clean, CES = CES_12_rc_clean, year = 2012),
  list(CPS = CPS_14_rc_clean, CES = CES_14_rc_clean, year = 2014),
  list(CPS = CPS_16_rc_clean, CES = CES_16_rc_clean, year = 2016),
  list(CPS = CPS_18_rc_clean, CES = CES_18_rc_clean, year = 2018),
  list(CPS = CPS_20_rc_clean, CES = CES_20_rc_clean, year = 2020),
  list(CPS = CPS_22_rc_clean, CES = CES_22_rc_clean, year = 2022)
  )
  
  assign("list_all_years", list_all_years, envir = .GlobalEnv)
}

# This does the inverse: If I make changes to each df inside of list_all_years, this function pushes those changes to the global environment, so each individual
# year reflects any changes made inside of list_all_years.
push_list_all_years_to_env <- function() {
  for (entry in list_all_years) {
    year <- entry$year
    
    # Construct object names
    cps_name <- paste0("CPS_", substr(year, 3, 4), "_rc_clean")
    ces_name <- paste0("CES_", substr(year, 3, 4), "_rc_clean")
    
    # Assign to global environment
    assign(cps_name, entry$CPS, envir = .GlobalEnv)
    assign(ces_name, entry$CES, envir = .GlobalEnv)
  }
}


update_ces_rc_datasets <- function() {
  ces_rc_datasets <- setNames(
  list(CES_06_rc, CES_08_rc, CES_10_rc, CES_12_rc, CES_14_rc, CES_16_rc, CES_18_rc, CES_20_rc, CES_22_rc),
  c("2006", "2008", "2010", "2012", "2014", "2016", "2018", "2020", "2022")
)
  assign("ces_rc_datasets", ces_rc_datasets, envir = .GlobalEnv)
}
```

# Recoding CES and CPS
## Codebook recodings
Recode CES and CPS to have corresponding levels for comparable variables. Ensure that CODEBOOK.xlsm is in the code directory at the same directory level as analysisHQ.Rmd. This function will output a recoded df in the form CES_YY_rc to the global environment. 

If alternate recodings are desired, make the change in the CODEBOOK, save it, and re-run the code below.
```{r message=FALSE, warning=FALSE, include=FALSE, paged.print=FALSE, results='hide'}
apply_codebook_and_recode(6)
apply_codebook_and_recode(8)
apply_codebook_and_recode(10)
apply_codebook_and_recode(12)
apply_codebook_and_recode(14)
apply_codebook_and_recode(16)
apply_codebook_and_recode(18)
apply_codebook_and_recode(20)
apply_codebook_and_recode(22)
```

## Manual recodings
```{r}
make_state_to_region <- function() {
  region_mapping <- list(
    "Northeast" = c("CT", "ME", "MA", "NH", "RI", "VT", "NJ", "NY", "PA"),
    "Midwest" = c("IL", "IN", "MI", "OH", "WI", "IA", "KS", "MN", "MO", "NE", "ND", "SD"),
    "South" = c("DE", "DC", "FL", "GA", "MD", "NC", "SC", "VA", "WV", "AL", "KY", "MS", "TN", "AR", "LA", "OK", "TX"),
    "West" = c("AZ", "CO", "ID", "MT", "NV", "NM", "UT", "WY", "AK", "CA", "HI", "OR", "WA"))

  # Flatten the mapping into a named vector
  state_abbr <- unlist(region_mapping)
  regions <- rep(names(region_mapping), times = lengths(region_mapping))
  setNames(regions, state_abbr)
}

state_to_region <- make_state_to_region()
```


```{r warning=FALSE}
year_mapping <- c("2006" = 1, "2008" = 2, "2010" = 3, "2012" = 4, "2014" = 5, "2016" = 6, "2018" = 7, "2020" = 8, "2022" = 9)

# Apply age groups to CES data frames
CES_06_rc$AGE_GROUP_rc <- calculate_age_groups(2006 - CES_06_rc$v2020)
CES_08_rc$AGE_GROUP_rc <- calculate_age_groups(2008 - CES_08_rc$V207)
CES_10_rc$AGE_GROUP_rc <- calculate_age_groups(2010 - CES_10_rc$V207)
CES_12_rc$AGE_GROUP_rc <- calculate_age_groups(2012 - CES_12_rc$birthyr)
CES_14_rc$AGE_GROUP_rc <- calculate_age_groups(2014 - CES_14_rc$birthyr)
CES_16_rc$AGE_GROUP_rc <- calculate_age_groups(2016 - CES_16_rc$birthyr)
CES_18_rc$AGE_GROUP_rc <- calculate_age_groups(2018 - CES_18_rc$birthyr)
CES_20_rc$AGE_GROUP_rc <- calculate_age_groups(2020 - CES_20_rc$birthyr)
CES_22_rc$AGE_GROUP_rc <- calculate_age_groups(2022 - CES_22_rc$birthyr)

# Apply age groups to CPS data frames
CPS_06_rc$AGE_GROUP_rc <- calculate_age_groups(CPS_06_rc$AGE)
CPS_08_rc$AGE_GROUP_rc <- calculate_age_groups(CPS_08_rc$AGE)
CPS_10_rc$AGE_GROUP_rc <- calculate_age_groups(CPS_10_rc$AGE)
CPS_12_rc$AGE_GROUP_rc <- calculate_age_groups(CPS_12_rc$AGE)
CPS_14_rc$AGE_GROUP_rc <- calculate_age_groups(CPS_14_rc$AGE)
CPS_16_rc$AGE_GROUP_rc <- calculate_age_groups(CPS_16_rc$AGE)
CPS_18_rc$AGE_GROUP_rc <- calculate_age_groups(CPS_18_rc$AGE)
CPS_20_rc$AGE_GROUP_rc <- calculate_age_groups(CPS_20_rc$AGE)
CPS_22_rc$AGE_GROUP_rc <- calculate_age_groups(CPS_22_rc$AGE)

# Add POST_STATE_rc to CPS data frames (have to include the 'post' so it aligns with CES)
data("fips_codes")
state_lookup <- fips_codes %>%
  select(state_code, state_name) %>%
  distinct() %>%
  mutate(
    state_code = as.integer(state_code),
    state_name = toupper(state_name)
  )

for (yr in c("06", "08", "10", "12", "14", "16", "18", "20", "22")) {
  df_name <- paste0("CPS_", yr, "_rc")
  df <- get(df_name)

  df <- df %>%
    mutate(STATEFIP = as.integer(STATEFIP)) %>%
    left_join(state_lookup, by = c("STATEFIP" = "state_code")) %>%
    rename(POST_STATE_rc = state_name)

  assign(df_name, df, envir = .GlobalEnv)
}

# Region
CES_06_rc$REGION_rc <- as.factor(state_to_region[CES_06_rc$v1002])
CES_08_rc$REGION_rc <- as.factor(state_to_region[fips(CES_08_rc$V206, to = "abbreviation")])
CES_10_rc$REGION_rc <- as.factor(state_to_region[fips(CES_10_rc$V206, to = "abbreviation")])
CES_12_rc$REGION_rc <- as.factor(state_to_region[fips(CES_12_rc$inputstate, to = "abbreviation")])
CES_14_rc$REGION_rc <- as.factor(state_to_region[fips(CES_14_rc$inputstate, to = "abbreviation")])
CES_16_rc$REGION_rc <- as.factor(state_to_region[fips(CES_16_rc$inputstate, to = "abbreviation")])
CES_18_rc$REGION_rc <- as.factor(state_to_region[fips(CES_18_rc$inputstate, to = "abbreviation")])
CES_20_rc$REGION_rc <- as.factor(state_to_region[fips(CES_20_rc$inputstate, to = "abbreviation")])
CES_22_rc$REGION_rc <- as.factor(state_to_region[fips(CES_22_rc$inputstate, to = "abbreviation")])

# Rename congressional district column
CES_06_rc$CDID_post_rc <- CES_06_rc$v1003
CES_08_rc$CDID_post_rc <- CES_08_rc$V264
CES_10_rc$CDID_post_rc <- CES_10_rc$V276_post
CES_12_rc$CDID_post_rc <- CES_12_rc$cdid113_post
CES_14_rc$CDID_post_rc <- CES_14_rc$cdid_post
CES_16_rc$CDID_post_rc <- CES_16_rc$cdid115_post
CES_18_rc$CDID_post_rc <- CES_18_rc$cdid116_post
CES_20_rc$CDID_post_rc <- CES_20_rc$cdid116_post
CES_22_rc$CDID_post_rc <- CES_22_rc$cdid118_post

# Add pre- and post- questionnaire state
update_ces_rc_datasets()
add_location_vars(ces_rc_datasets, pre_post_location_vars)
update_ces_rc_datasets()

# Ensure POST_STATE_rc is a factor
CES_06_rc$POST_STATE_rc <- as.factor(CES_06_rc$POST_STATE_rc)
CES_08_rc$POST_STATE_rc <- as.factor(CES_08_rc$POST_STATE_rc)
CES_10_rc$POST_STATE_rc <- as.factor(CES_10_rc$POST_STATE_rc)
CES_12_rc$POST_STATE_rc <- as.factor(CES_12_rc$POST_STATE_rc)
CES_14_rc$POST_STATE_rc <- as.factor(CES_14_rc$POST_STATE_rc)
CES_16_rc$POST_STATE_rc <- as.factor(CES_16_rc$POST_STATE_rc)
CES_18_rc$POST_STATE_rc <- as.factor(CES_18_rc$POST_STATE_rc)
CES_20_rc$POST_STATE_rc <- as.factor(CES_20_rc$POST_STATE_rc)
CES_22_rc$POST_STATE_rc <- as.factor(CES_22_rc$POST_STATE_rc)
                                     
                                     
cps_rc_datasets <- list(CPS_06_rc, CPS_08_rc, CPS_10_rc, CPS_12_rc, CPS_14_rc, CPS_16_rc, CPS_18_rc, CPS_20_rc, CPS_22_rc)

list2env(setNames(cps_rc_datasets, c("CPS_06_rc", "CPS_08_rc", "CPS_10_rc", "CPS_12_rc", "CPS_14_rc", "CPS_16_rc", "CPS_18_rc", "CPS_20_rc", "CPS_22_rc")), envir = .GlobalEnv)


# Clean up NAs (ie. make sure "NA", __NA__, "NA_char" are all treated as data type NA)
CES_06_rc_clean <- clean_NAs(CES_06_rc)
CPS_06_rc_clean <- clean_NAs(CPS_06_rc)

CES_08_rc_clean <- clean_NAs(CES_08_rc)
CPS_08_rc_clean <- clean_NAs(CPS_08_rc)

CES_10_rc_clean <- clean_NAs(CES_10_rc)
CPS_10_rc_clean <- clean_NAs(CPS_10_rc)

CES_12_rc_clean <- clean_NAs(CES_12_rc)
CPS_12_rc_clean <- clean_NAs(CPS_12_rc)

CES_14_rc_clean <- clean_NAs(CES_14_rc)
CPS_14_rc_clean <- clean_NAs(CPS_14_rc)

CES_16_rc_clean <- clean_NAs(CES_16_rc)
CPS_16_rc_clean <- clean_NAs(CPS_16_rc)

CES_18_rc_clean <- clean_NAs(CES_18_rc)
CPS_18_rc_clean <- clean_NAs(CPS_18_rc)

CES_20_rc_clean <- clean_NAs(CES_20_rc)
CPS_20_rc_clean <- clean_NAs(CPS_20_rc)

CES_22_rc_clean <- clean_NAs(CES_22_rc)
CPS_22_rc_clean <- clean_NAs(CPS_22_rc)

CES_06_rc_clean <- as.data.frame(CES_06_rc_clean)
CES_08_rc_clean <- as.data.frame(CES_08_rc_clean)
CES_10_rc_clean <- as.data.frame(CES_10_rc_clean)
CES_12_rc_clean <- as.data.frame(CES_12_rc_clean)
CES_14_rc_clean <- as.data.frame(CES_14_rc_clean)
CES_16_rc_clean <- as.data.frame(CES_16_rc_clean)
CES_18_rc_clean <- as.data.frame(CES_18_rc_clean)
CES_20_rc_clean <- as.data.frame(CES_20_rc_clean)
CES_22_rc_clean <- as.data.frame(CES_22_rc_clean)

update_list_all_years()
```

# Recode Party and Candidate Vote
For 2006 and 2008, respondent vote choices could be directly mapped to a party because the response options were simply "Democrat," "Republican," and "Other". However, from 2010 - 2022, the CES changed the response options. Instead of using party names, respondents were provided candidate names. These names were inputted dynamically based on other "contextual" variables that recorded candidate names for a particular respondent based on their state of residence.

This means that error can be calculated in two ways: at the party level (by aggregating across all candidates of a particular party), and at the candidate level (by comparing CES votes for a particular candidate to actual votes received by that specific candidate).

Thus, I create two variables for each CES respondent. The first will be named [RACE]_PARTY_rc and will contain indicate the Party that the respondent voted for. In the cases when a respondent was presented a candidate name, the party will be filled in based on the provided contextual variables. The second will be [RACE]_CANDIDATE_rc and will contain the name of the candidate that the respondent voted for.

Note: Once you have run the two functions below once, you cannot run them again on the same dfs. You would need to go back and re-run everything from "Codebook recodings."
```{r}
#' Recode Party and Candidate Vote Variables from Dynamic References
#'
#' If a cell is "Democrat", "Republican", "Other", or NA, it’s left alone. Otherwise, the cell’s 
#' value is treated as a column name (e.g., "PRES_PARTY_post"). If that column exists, the cell is 
#' replaced with the value from that referenced column on the same row.

#' @return A list of the same structure, with each `CES` data.frame updated
#'   in-place so that dynamic references (column names stored in cells)
#'   have been replaced by their actual values.
#'
#' @details  
#' - Columns matching `"_PARTY_rc$"` (except those containing `"SENATOR2"` or
#'   `"SENATOREARLY"`) are always recoded.  
#' - Columns matching `"_CANDIDATE_rc$"` (same exclusions) are recoded for
#'   years **other than** 2006 and 2008.  
#' - Factor columns in each `CES` frame are coerced to character prior to
#'   recoding, and the recoded party columns are converted back to factors.
#'
recode_party_and_candidate_votes <- function(list_all_years) {
  no_recode <- c("Democrat", "Republican", "Other")  # values to be left alone
  
  n_years <- length(list_all_years)
  pb <- txtProgressBar(min = 0, max = n_years, style = 3)

  for (i in seq_along(list_all_years)) {
    year <- list_all_years[[i]]$year
    setTxtProgressBar(pb, i)
    cat(sprintf("  Processing year: %s\r", year))
    flush.console()

    year_entry <- list_all_years[[i]]
    year_chr   <- as.character(year_entry$year)
    df         <- year_entry$CES

    # identify the columns to fix
    party_cols     <- grep("_PARTY_rc$", names(df), value = TRUE)
    party_cols     <- party_cols[!grepl("SENATOR2|SENATOREARLY", party_cols)]
    candidate_cols <- grep("_CANDIDATE_rc$", names(df), value = TRUE)
    candidate_cols     <- candidate_cols[!grepl("PRES|SENATOR2|SENATOREARLY", candidate_cols)]
    
    cols_to_edit <- unique(c(party_cols, candidate_cols))
    df[cols_to_edit] <- lapply(df[cols_to_edit], as.character)


    # --- PARTY columns ---
    for (col in party_cols) {
      for (r in seq_len(nrow(df))) {
        val <- df[[col]][r]
        if (!(val %in% no_recode) && !is.na(val)) {
          # val should be the name of a contextual variable column
          if (! val %in% names(df)) {
            stop(sprintf(
              "Year %s: column '%s', row %d: reference '%s' not found",
              year_chr, col, r, val
            ))
          }
          df[[col]][r] <- as.character(df[[ val ]][r])
        }
      }
    }

    # --- CANDIDATE columns (skip 2006 & 2008) ---
    if (! year_chr %in% c("2006", "2008")) {
      for (col in candidate_cols) {
        for (r in seq_len(nrow(df))) {
          val <- df[[col]][r]
          if (!(val %in% no_recode) && !is.na(val)) {
            if (! val %in% names(df)) {
              stop(sprintf(
                "Year %s: column '%s', row %d: reference '%s' not found",
                year_chr, col, r, val
              ))
            }
            df[[col]][r] <- as.character(df[[ val ]][r])
          }
        }
      }
    }
    
    df[party_cols]     <- lapply(df[party_cols],     factor)

    # put the modified CES DF back
    list_all_years[[i]]$CES <- df
  }

  close(pb)
  list_all_years
}


```

Function to clean all the PARTY columns, to ensure consistent naming
```{r}
#' Standardize Party Labels in CES Data
#'
#' This function iterates over each year's CES data in a list and standardizes the values
#' in all `*_PARTY_rc` columns according to a set of cleaning rules:
#'
#' - `"Democrat"` and `"Republican"` are kept as-is.
#' - `"Democratic-Republican"` is recoded as `"Other"`.
#' - Any other value containing `"Democratic"` is recoded to `"Democrat"`.
#' - All other values (e.g., `"Green"`, `"Libertarian"`, NA) are recoded to `"Other"`.
#'
#' After recoding, all `*_PARTY_rc` columns are re-cast as factors with levels
#' `c("Democrat", "Republican", "Other")`.
#'
#' @param list_all_years A named list of lists, each containing a CES data frame under `$CES`.
#' @return The same list with party names cleaned in all `_PARTY_rc` columns.
#' @export
clean_party_names <- function(list_all_years) {
  for (i in seq_along(list_all_years)) {
    entry <- list_all_years[[i]]
    df    <- entry$CES

    party_cols <- grep("_PARTY_rc$", names(df), value = TRUE)

    for (col in party_cols) {
      original <- as.character(df[[col]])
      cleaned <- case_when(
        is.na(original) ~ NA,
        original == "Democrat" ~ "Democrat",
        original == "Republican" ~ "Republican",
        original == "Democratic-Republican" ~ "Other",
        grepl("Democratic", original, ignore.case = FALSE) ~ "Democrat",
        TRUE ~ "Other"
      )
      df[[col]] <- factor(cleaned, levels = c("Democrat", "Republican", "Other"))
    }

    list_all_years[[i]]$CES <- df
  }

  return(list_all_years)
}
```



Update list_all_years, run the recoding, clean party names, then push changes from list_all_years back to global environment to keep list_all_years synced with each individual CES year in the global environment.
```{r}
update_list_all_years()
recoded_party_candidate_list_all_years <- recode_party_and_candidate_votes(list_all_years)
recoded_party_candidate_list_all_years_cleaned <- clean_party_names(recoded_party_candidate_list_all_years)
list_all_years <- recoded_party_candidate_list_all_years_cleaned
push_list_all_years_to_env()
```

# Temp workspace 10.17.25
```{r}


```


# Create Party-level Election Return Prop Tables
The raw election return files are loaded in the "Election Return Datasets" section. The following code creates a series of "prop" (proportion) tables for each election, then collapses across party to indicate what share of votes each party received in each election. 
```{r}
# US House
House_0622_clean_fixed <- recalculate_total_votes(House_0622, "statewide")
house_prop_table <- calculate_state_level_party_proportions(House_0622_clean_fixed) 
house_prop_table$Office <- "US House"

# US Senate
Senate_0622_clean_fixed <- recalculate_total_votes(Senate_0622, "statewide")
senate_cand_prop_table <- calculate_cand_num_proportions(Senate_0622_clean_fixed) %>%
  mutate(office = "US Senate") %>%
  rename(
    Office = office,
    State = state,
    District = district,
    Year = year,
    Candidate = candidate_name,
    Cand_Num = cand_num,
    Party_Detailed = party_detailed,
    Party_Simplified = party_simplified,
    Candidate_Votes = candidatevotes,
    Total_Votes = totalvotes,
    Proportion = proportion
  )

# Governor
Governor_0622_clean_fixed <- recalculate_total_votes(Governor_0622, "statewide")
governor_cand_prop_table <- calculate_cand_num_proportions(Governor_0622_clean_fixed) %>%
  mutate(office = "Governor") %>%
  rename(
    Office = office,
    State = state,
    District = district,
    Year = year,
    Candidate = candidate_name,
    Cand_Num = cand_num,
    Party_Detailed = party_detailed,
    Party_Simplified = party_simplified,
    Candidate_Votes = candidatevotes,
    Total_Votes = totalvotes,
    Proportion = proportion
  )

# President
President_0820_nums <- assign_president_candidate_numbers(President_0820) %>%
  filter(candidate %notin% c("OVER VOTE", "OVERVOTE", "OVERVOTES", "OVER VOTES"))
president_candid_prop_table <- calculate_cand_num_proportions(President_0820_nums) %>%
  mutate(office = "President") %>%
  rename(
    Office = office,
    State = state,
    District = district,
    Year = year,
    Candidate = candidate_name,
    Cand_Num = cand_num,
    Party_Detailed = party_detailed,
    Party_Simplified = party_simplified,
    Candidate_Votes = candidatevotes,
    Total_Votes = totalvotes,
    Proportion = proportion
  )

# State Senate
state_upper_prop_table <- make_bp_prop_table(State_senate_full) %>%
  mutate(Office = "State Senator") %>%   
  select(Office, everything())    

# State House
state_lower_prop_table <- make_bp_prop_table(State_house_full) %>%
  mutate(Office = "State Representative") %>%   
  select(Office, everything())    

# Attorney General
attorney_general_prop_table <- make_bp_prop_table(Attorney_general_full) %>%
  mutate(Office = "Attorney General") %>%   
  select(Office, everything()) 

# Secretary of State
secretary_of_state_prop_table <- make_bp_prop_table(Secretary_of_state_full) %>%
  mutate(Office = "Secretary of State") %>%   
  select(Office, everything()) 

merge_list <- list(
  governor_cand_prop_table,
  senate_cand_prop_table,
  state_upper_prop_table,
  state_lower_prop_table,
  attorney_general_prop_table,
  secretary_of_state_prop_table,
  president_candid_prop_table
)

merged_prop_tables <- merge_list %>%
  map(~ .x %>%
        mutate(Year = as.integer(parse_number(as.character(Year)))) %>%
        select(-any_of("Candidate_Votes"))
      ) %>%
  bind_rows()

# Merge all results
# merged_prop_tables <- rbind(governor_cand_prop_table, senate_cand_prop_table, state_upper_prop_table, state_lower_prop_table, attorney_general_prop_table, secretary_of_state_prop_table, president_candid_prop_table)
```

Collapsing prop table across party
```{r}
collapse_proportion_table <- function(df) {
  df %>%
    group_by(State, Year = as.numeric(Year), Office, Party_Simplified) %>%
    summarise(Proportion = sum(Proportion, na.rm = TRUE), .groups = "drop") %>%
    pivot_wider(
      names_from = Party_Simplified,
      values_from = Proportion,
      names_prefix = "",
      values_fill = 0
    ) %>%
    rename(
      DEM_Proportion = DEM,
      REP_Proportion = REP,
      OTHER_Proportion = OTHER
    ) %>%
    select(State, Year, Office, DEM_Proportion, OTHER_Proportion, REP_Proportion)
}

collapsed_merged_prop_table <- collapse_proportion_table(merged_prop_tables)
merged_prop_tables_combined <- rbind(collapsed_merged_prop_table, house_prop_table)
```


# Create Candidate-Level Election Return Prop Tables
Now I create a candidate-level prop table, which will be used to compare the CES vote to the actual votes received by each candidate in each election. This is done by creating a table that contains the proportion of votes received by each candidate in each state, for each year, and not grouping by party. 
```{r}
candidate_level_proportions <- function(df) {

  # summarize votes per candidate per race in case same candidate appears multiple times under different parties
  summed_votes <- df %>%
    group_by(year, state, office, district, candidate) %>%
    summarise(
      Candidate_Votes = sum(candidatevotes, na.rm = TRUE),
      Total_Votes = first(totalvotes),
      .groups = "drop"
    )

  # get party info from row with max candidate votes per group
  top_party <- df %>%
    group_by(year, state, office, district, candidate) %>%
    slice_max(candidatevotes, n = 1, with_ties = FALSE) %>%
    select(
      year, state, office, district, candidate,
      Party_Detailed = party_detailed,
      Party_Simplified = party_simplified
    )

  # combine and compute proportion
  cleaned <- summed_votes %>%
    left_join(top_party, by = c("year", "state", "office", "district", "candidate")) %>%
    mutate(Proportion = Candidate_Votes / Total_Votes) %>%
    select(
      Office = office,
      State = state,
      District = district,
      Year = year,
      Candidate = candidate,
      Party_Detailed,
      Party_Simplified,
      Candidate_Votes,
      Total_Votes,
      Proportion
    )

  return(cleaned)
}
```

```{r}
# US House
House_0622_district <- recalculate_total_votes(House_0622, "district")
house_candidate_level_props <- candidate_level_proportions(House_0622_district)
house_candidate_level_props$Office <- "US House"

# US Senate
senate_candidate_level_props  <- candidate_level_proportions(Senate_0622_clean_fixed)
senate_candidate_level_props$Office <- "US Senate"

# Governor
governor_candidate_level_props  <- candidate_level_proportions(Governor_0622_clean_fixed)
governor_candidate_level_props$Office <- "Governor"

# President
President_0820_candidate_level_props <- assign_president_candidate_numbers(President_0820) %>%
  filter(candidate %notin% c("OVER VOTE", "OVERVOTE", "OVERVOTES", "OVER VOTES"))

president_candidate_level_props <- calculate_cand_num_proportions(President_0820_candidate_level_props) %>%
  mutate(office = "President") %>%
  rename(
    Office = office,
    State = state,
    District = district,
    Year = year,
    Candidate = candidate_name,
    Party_Detailed = party_detailed,
    Party_Simplified = party_simplified,
    Candidate_Votes = candidatevotes,
    Total_Votes = totalvotes,
    Proportion = proportion
  ) %>%
  select(Office, State, District, Year, Candidate, Party_Detailed, Party_Simplified, Candidate_Votes, Total_Votes, Proportion)

# Attorney General
attorney_general_candidate_level_props <- candidate_level_BP_statewide_offices(Attorney_general_full) %>%
  mutate(Office = "Attorney General") %>%   
  select(Office, everything()) 

# Secretary of State
secretary_of_state_candidate_level_props <- candidate_level_BP_statewide_offices(Secretary_of_state_full) %>%
  mutate(Office = "Secretary of State") %>%   
  select(Office, everything()) 


# Merge all results
merged_candidate_level_props <- rbind(president_candidate_level_props, senate_candidate_level_props, house_candidate_level_props, governor_candidate_level_props, attorney_general_candidate_level_props, secretary_of_state_candidate_level_props)

merged_candidate_level_props <- merged_candidate_level_props %>%
  mutate(
    Candidate = format_reverse(Candidate),
    State = toupper(State)
  )

```


# Create Weighting Targets
ANESRake requires that "targets" are created for each variable, which specify the expected distribution of that variable in the population for each level of that variable.
```{r}
# Some variables require special weighting variables. This dictionary specifies which weighting variable should be used for those special variables, otherwise
# the common weighting var is used. 
create_targets <- function(year_data_list) {
  cps_wtvar_dict <- c(
  "UNION_rc" = "EARNWT",
  "VOTED_rc" = "VOSUPPWT",
  "VOTEHOW_rc" = "VOSUPPWT",
  "VOTERES_rc" = "VOSUPPWT",
  "VOTEREG_rc" = "VOSUPPWT"
)
  
  # Create a list to store targets for each year
  all_targets <- list()
  
  # Loop through each year's data
  for (year_data in year_data_list) {
    cps_df <- year_data$CPS
    ces_df <- year_data$CES
    current_year <- year_data$year
    
    # Create a list of all recoded variables for CES data
    variables <- intersect(names(ces_df), names(cps_df))
    # Exclude variables I don't want to use in weighting
    variables <- variables[!grepl("DUM|OVERTIME|REGION_rc|CUR_MIL_rc|CLASSWKR_rc", variables)]
  
    # Create population (cps) numeric values list with level names
    targets <- list()
    for (var in variables) {
      #browser()
      if (var == "VOTED_rc") {
        rate <- turnout_national %>%
          filter(Year == current_year) %>%
          pull(Rate)
        
        numeric_values <- c(rate, 1 - rate)
        names(numeric_values) <- c("Voted", "Did not vote")
        
      }
      
      else {
      # Determine the appropriate weight variable
      weight_var <- if (var %in% names(cps_wtvar_dict)) cps_wtvar_dict[var] else "WTFINL"
      
      # Calculate weighted proportions for each level using wpct
      weighted_proportions <- wpct(cps_df[[var]], weight = cps_df[[weight_var]], na.rm=TRUE)
      
      # Convert proportions to numeric values with level names
      numeric_values <- as.numeric(weighted_proportions)
      names(numeric_values) <- names(weighted_proportions)
      }

      # Store numeric values in the list
      targets[[var]] <- numeric_values
    }
    
    # Append targets for the current year to the list of all targets
    target_name <- paste0(current_year)
    all_targets[[target_name]] <- targets
  }
  
  return(all_targets)
}
```

Update list_all_years, then create targets for each year for all variables that are present in both CES and CPS.
```{r}
update_list_all_years()
all_targets <- create_targets(list_all_years)
```

# Create ANESRake Weights
Function to run ANESRake weighting for each year
```{r}
run_weighting <- function(year_list,
                          targets,
                          year_data_list = list_all_years,
                          type = "pctlim",        # "pctlim", "nlim", "nmin", "nmax", or "nolim"
                          pctlim = 5,             # % threshold for "pctlim"
                          nlim = 5,               # n for "nlim"/"nmax"
                          choosemethod = "total", # how anesrakefinder scores discrepancy
                          verbose = FALSE) {
  results_list <- list()

  for (year in year_list) {
    message("Year: ", year)

    # Find the matching year data directly
    year_data <- year_data_list[[which(sapply(year_data_list, function(x) x$year == year))]]

    if (is.null(year_data)) {
      stop(glue::glue("Year {year} not found in year_data_list"))
    }

    target_data <- targets[[as.character(year)]]
    CES_data    <- year_data$CES
    caseid_col  <- CES_data[, 1]

    outsave <- anesrake(
      inputter     = target_data,
      dataframe    = CES_data,
      caseid       = caseid_col,
      verbose      = verbose,
      type         = type,
      pctlim       = pctlim,
      nlim         = nlim,
      choosemethod = choosemethod
    )

    caseweights <- data.frame(cases = outsave$caseid, weights = outsave$weightvec)

    # Which variables were actually used
    vars_used <- outsave$varsused

    # Make a tidy record of targets used (only those actually raked on)
    targets_used <- lapply(vars_used, function(v) {
      tv <- outsave$targets[[v]]
      data.frame(Variable = v,
                 Level    = names(tv),
                 Target   = as.numeric(tv),
                 row.names = NULL,
                 check.names = FALSE)
    })
    targets_used <- do.call(rbind, targets_used)

    # Store results
    results_list[[as.character(year)]] <- list(
      caseweights      = caseweights,
      vars_used        = vars_used,
      weighting_meta   = list(
        type          = outsave$type,
        choosemethod  = outsave$choosemethod,
        iterations    = outsave$iterations,
        converged     = outsave$converge,
        nonconvergence= outsave$nonconvergence
      ),
      targets_used     = targets_used,
      outsave_summary  = summary(outsave)  # pretty console summary
    )
  }

  return(results_list)
}

weighting_results <- run_weighting(c(2006, 2008, 2010, 2012, 2014, 2016, 2018, 2020, 2022), 
                                   all_targets)

# Cross-reference proposed vs used variables, by year
vars_used_vs_all <- do.call(rbind, lapply(names(weighting_results), function(y_chr) {
  # keys might be numeric or character; normalize
  y <- as.character(y_chr)

  proposed <- names(all_targets[[y]])
  used     <- weighting_results[[y]]$vars_used

  # Build row per proposed variable
  data.frame(
    Year     = y,
    Variable = proposed,
    Used     = proposed %in% used,
    stringsAsFactors = FALSE
  )
}))

# Just the excluded ones (not used)
vars_excluded_by_year <- subset(vars_used_vs_all, !Used)


```

Create weights for all years
```{r}
weighting_results <- run_weighting(c(2006, 2008, 2010, 2012, 2014, 2016, 2018, 2020, 2022), all_targets)
```


Add the new weight column to each year's df
```{r}
add_weights_to_df <- function(df, year, weighting_results) {
  # Check if the weight is already present
  if ("anesrake_weight" %in% colnames(df)) {
    message(paste0("anesrake_weight already present in ", year))
    return(df)
  }
  
  # Extract weights and case IDs from the results for the specified year
  weights <- weighting_results[[as.character(year)]]$caseweights
  weights <- weights[order(weights$cases), ]  # Sort by case IDs
  
  # Merge weights with the dataframe
  merged_df <- merge(df, weights, by.x = 1, by.y = "cases", all.x = TRUE)  # Assuming case ID column is the first column
  
  # Rename the weights column
  colnames(merged_df)[ncol(merged_df)] <- "anesrake_weight"
  
  return(merged_df)
}

```

Add new weighting column to each CES df
```{r}
CES_06_rc_clean <- add_weights_to_df(CES_06_rc_clean, 2006, weighting_results)
CES_08_rc_clean <- add_weights_to_df(CES_08_rc_clean, 2008, weighting_results)
CES_10_rc_clean <- add_weights_to_df(CES_10_rc_clean, 2010, weighting_results)
CES_12_rc_clean <- add_weights_to_df(CES_12_rc_clean, 2012, weighting_results)
CES_14_rc_clean <- add_weights_to_df(CES_14_rc_clean, 2014, weighting_results)
CES_16_rc_clean <- add_weights_to_df(CES_16_rc_clean, 2016, weighting_results)
CES_18_rc_clean <- add_weights_to_df(CES_18_rc_clean, 2018, weighting_results)
CES_20_rc_clean <- add_weights_to_df(CES_20_rc_clean, 2020, weighting_results)
CES_22_rc_clean <- add_weights_to_df(CES_22_rc_clean, 2022, weighting_results)
update_list_all_years()
```

# Compute CES Errors
CES error is measured in the following ways:
  - Candidate choice at the Party-level: compare vote share for the leading party (e.g., Democrats 55%).
  - Candidate choice at the Candidate-level: compare vote share for the leading candidate (e.g., Obama 55%).
  - Demographic and voting variables ("demoplus"): compare true population proportions to CES proportions for demographic and voting behavior variables (e.g., union membership, voter turnout, etc.).

```{r}
# Weighting vars for each year
yearly_ces_wt_vars <- list(
  "2006" = c("v1001", "anesrake_weight"),
  "2008" = c("V201", "anesrake_weight"),
  "2010" = c("V101", "anesrake_weight"),
  "2012" = c("V103", "anesrake_weight"),
  "2014" = c("weight", "anesrake_weight"),
  "2016" = c("commonweight_post", "commonweight", "anesrake_weight"),
  "2018" = c("commonpostweight", "commonweight","anesrake_weight"),
  "2020" = c("commonpostweight", "commonweight",  "anesrake_weight"),
  "2022" = c("commonpostweight", "commonweight", "anesrake_weight"))

# Variables used by the CES for post-stratification in each year
# This is necessary for classifying variables as "primary" or "secondary"
vars_used_ces_weights <- list(
  `2006` = character(0),
  `2008` = c("AGE_GROUP_rc", "EDUC_rc", "SEX_rc", "VOTED_rc"),
  `2010` = c("AGE_GROUP_rc", "EDUC_rc", "SEX_rc", "VOTED_rc"),
  `2012` = c("AGE_GROUP_rc", "EDUC_rc", "SEX_rc", "VOTED_rc"),
  `2014` = c(
    "AGE_GROUP_rc", "SEX_rc", "EDUC_rc", "VOTEREG_rc",
    "POST_STATE_rc", "GOV_CANDIDATE_rc", "GOV_PARTY_rc",
    "SENATOR_CANDIDATE_rc", "SENATOR_PARTY_rc"
  ),
  `2016` = c(
    "AGE_GROUP_rc", "SEX_rc", "EDUC_rc", "VOTEREG_rc",
    "POST_STATE_rc", "GOV_CANDIDATE_rc", "GOV_PARTY_rc",
    "SENATOR_CANDIDATE_rc", "SENATOR_PARTY_rc"
  ),
  `2018` = c(
    "SEX_rc", "AGE_GROUP_rc", "HISPANIC_rc", "EDUC_rc",
    "VOTEREG_rc", "POST_STATE_rc", "GOV_CANDIDATE_rc", 
    "GOV_PARTY_rc", "SENATOR_CANDIDATE_rc", "SENATOR_PARTY_rc"
  ),
  `2020` = c(
    "SEX_rc", "AGE_GROUP_rc", "HISPANIC_rc", "EDUC_rc",
    "VOTEREG_rc", "POST_STATE_rc", "GOV_CANDIDATE_rc", "GOV_PARTY_rc",
    "SENATOR_CANDIDATE_rc", "SENATOR_PARTY_rc"
  ),
  `2022` = c(
    "SEX_rc", "AGE_GROUP_rc", "HISPANIC_rc", "EDUC_rc",
    "VOTEREG_rc", "POST_STATE_rc", "GOV_CANDIDATE_rc", "GOV_PARTY_rc",
    "SENATOR_CANDIDATE_rc", "SENATOR_PARTY_rc"
  )
)
```

```{r}
# Create accuracy configuration object
config <- create_accuracy_config(
  yearly_ces_wt_vars = yearly_ces_wt_vars,
  skip_conditions = skip_conditions,
  NC_flag_df = NC_flag_df,
  vars_used_ces_weights = vars_used_ces_weights,
  anesrake_results = weighting_results  # From ANESRake weighting step
)
```

## Calculate party-level election errors
```{r}
party_errors <- calculate_party_errors(
  year_data_list = list_all_years,
  election_results_df = merged_prop_tables_combined,
  config = config
) %>%
  standardize_variable_names()
```

## Calculate candidate-level election errors
```{r}
# Candidate-level is only calculated at modal level to begin with
candidate_errors_modal <- calculate_candidate_errors(
  year_data_list = list_all_years,
  candidate_returns_df = merged_candidate_level_props,
  config = config
) %>%
  standardize_variable_names()
```

## Calculate demovote errors (demographics + voting)
```{r}
# Automatically extracts all comparison variables from all_targets
# VOTED_rc (turnout) uses actual state turnout rates as benchmark
# POST_STATE_rc (state residence) uses actual state populations as benchmark
# All other variables use CPS as benchmark

demovote_errors <- calculate_demovote_errors(
  year_data_list = list_all_years,
  all_targets = all_targets,  # Automatically extracts all comparable variables
  config = config,
  turnout_statewide = turnout_statewide,  # For accurate turnout benchmarks
  state_populations = state_populations    # For accurate state sampling benchmarks
) %>%
  standardize_variable_names()
```

## Keep modal category only
```{r}
# Candidate is already modal
party_errors_modal <- keep_modal_only(party_errors)
demovote_errors_modal <- keep_modal_only(demovote_errors)
```

## Combining Errors
```{r}
# ===============================
# Party-level + Demovote
# ===============================
party_demovote_wide <- bind_rows(
  party_errors_modal,
  demovote_errors_modal
)

# ===============================
# Candidate-level + Demovote
# ===============================
candidate_demovote_wide <- bind_rows(
  candidate_errors_modal,  # Not modalized - already modal
  demovote_errors_modal
)

# ===============================
# Most-specific-available table
# ===============================
# Use candidate-level when available, fall back to party-level otherwise

# Define candidate-choice variables
final_cand_choice_vars <- c(
  "President", "U.S. Senate", "U.S. House", "Governor",
  "Secretary of State", "Attorney General", "State Senator", "State Representative"
)

# Candidate-level keepers by year rules
cand_keep <- bind_rows(
  # 2010–2016: candidate-level for Pres/Sen/House/Gov
  candidate_errors_modal %>%
    filter(Class == "Candidate Choice",
           Year >= 2010, Year <= 2016,
           Variable %in% c("President", "U.S. Senate", "U.S. House", "Governor")),

  # 2018–2022: candidate-level adds SecState + AG
  candidate_errors_modal %>%
    filter(Class == "Candidate Choice",
           Year >= 2018, Year <= 2022,
           Variable %in% c("President", "U.S. Senate", "U.S. House", "Governor",
                          "Secretary of State", "Attorney General"))
)

# Party-level fallback by year rules
party_keep <- bind_rows(
  # 2006 & 2008: all candidate-choice from party-level
  party_errors_modal %>%
    filter(Class == "Candidate Choice",
           Year %in% c(2006, 2008),
           Variable %in% final_cand_choice_vars),

  # 2010–2016: party-level for SecState, AG, State Leg
  party_errors_modal %>%
    filter(Class == "Candidate Choice",
           Year >= 2010, Year <= 2016,
           Variable %in% c("Secretary of State", "Attorney General",
                          "State Senator", "State Representative")),

  # 2018–2022: party-level only for State Leg
  party_errors_modal %>%
    filter(Class == "Candidate Choice",
           Year >= 2018, Year <= 2022,
           Variable %in% c("State Senator", "State Representative"))
)

# Most-specific-available: demographics + best available candidate choice
most_specific_wide <- bind_rows(
  demovote_errors_modal,
  cand_keep,
  party_keep
) %>%
  arrange(Year, State, Class, Variable, Category)

```

# temp test testing for comparison between old and new
```{r}

  # ==============================================================================
  # STEP 1: Prepare both tables for comparison
  # ==============================================================================

  # New table: Convert wide to long (variable names already standardized!)
  most_specific_long_new <- most_specific_wide %>%
    pivot_longer(
      cols = c(Error_Unweighted, Error_CES_Weighted, Error_ANESRake),
      names_to = "Weighting_Method",
      values_to = "Value"
    ) %>%
    mutate(
      Year = as.numeric(Year),
      Weighting_Method = case_when(
        Weighting_Method == "Error_Unweighted"   ~ "CES-Unweighted",
        Weighting_Method == "Error_CES_Weighted" ~ "CES-Provided Weights",
        Weighting_Method == "Error_ANESRake"     ~ "ANESRake",
        TRUE ~ Weighting_Method
      ),
      Metric = "Modal Error"
    )

  # Old table: Just ensure Year is numeric
  most_specific_long_old <- most_specific_modal_error_table_all %>%
    mutate(Year = as.numeric(Year))

  cat("=== TABLE SIZES ===\n")
  cat("Old table rows:", nrow(most_specific_long_old), "\n")
  cat("New table rows:", nrow(most_specific_long_new), "\n")
  cat("Expected new rows (wide × 3 weighting methods):", nrow(most_specific_wide) * 3, "\n\n")

  # Check what Classes are in each
  cat("=== CLASS VALUES ===\n")
  cat("Classes in OLD table:\n")
  print(table(most_specific_long_old$Class))
  cat("\nClasses in NEW table:\n")
  print(table(most_specific_long_new$Class))
  cat("\n")

  # ==============================================================================
  # STEP 2: Get unique identifiers from each
  # ==============================================================================

  old_keys <- most_specific_long_old %>%
    distinct(Year, State, Class, Variable, Category, Weighting_Method) %>%
    arrange(Year, State, Class, Variable, Category, Weighting_Method)

  new_keys <- most_specific_long_new %>%
    distinct(Year, State, Class, Variable, Category, Weighting_Method) %>%
    arrange(Year, State, Class, Variable, Category, Weighting_Method)

  cat("=== COMPARISON SUMMARY ===\n")
  cat("Old table unique observations:", nrow(old_keys), "\n")
  cat("New table unique observations:", nrow(new_keys), "\n")
  cat("Difference:", nrow(new_keys) - nrow(old_keys), "\n\n")

  # ==============================================================================
  # STEP 3: Find missing observations
  # ==============================================================================

  missing_in_new <- anti_join(
    old_keys,
    new_keys,
    by = c("Year", "State", "Class", "Variable", "Category", "Weighting_Method")
  )

  cat("=== OBSERVATIONS IN OLD BUT NOT IN NEW ===\n")
  cat("Count:", nrow(missing_in_new), "\n")
  if (nrow(missing_in_new) > 0) {
    cat("\nFirst 20 rows:\n")
    print(head(missing_in_new, 20))

    cat("\nBreakdown by Variable:\n")
    print(missing_in_new %>% count(Variable, sort = TRUE))

    cat("\nBreakdown by Year:\n")
    print(missing_in_new %>% count(Year, sort = TRUE))

    cat("\nBreakdown by Class:\n")
    print(missing_in_new %>% count(Class, sort = TRUE))
  } else {
    cat("✅ None - all old observations present in new!\n")
  }

  cat("\n\n")

  extra_in_new <- anti_join(
    new_keys,
    old_keys,
    by = c("Year", "State", "Class", "Variable", "Category", "Weighting_Method")
  )

  cat("=== OBSERVATIONS IN NEW BUT NOT IN OLD ===\n")
  cat("Count:", nrow(extra_in_new), "\n")
  if (nrow(extra_in_new) > 0) {
    cat("\nFirst 20 rows:\n")
    print(head(extra_in_new, 20))

    cat("\nBreakdown by Variable:\n")
    print(extra_in_new %>% count(Variable, sort = TRUE))

    cat("\nBreakdown by Year:\n")
    print(extra_in_new %>% count(Year, sort = TRUE))

    cat("\nBreakdown by Class:\n")
    print(extra_in_new %>% count(Class, sort = TRUE))
  } else {
    cat("✅ None - no extra observations in new!\n")
  }

  cat("\n\n")

  # ==============================================================================
  # STEP 4: Compare error values for matching observations
  # ==============================================================================

  comparison <- inner_join(
    most_specific_long_old %>%
      select(Year, State, Class, Variable, Category, Weighting_Method, Value_Old = Value),
    most_specific_long_new %>%
      select(Year, State, Class, Variable, Category, Weighting_Method, Value_New = Value),
    by = c("Year", "State", "Class", "Variable", "Category", "Weighting_Method")
  ) %>%
    mutate(
      Difference = Value_New - Value_Old,
      Abs_Difference = abs(Difference),
      Pct_Difference = if_else(abs(Value_Old) < 0.0001, NA_real_,
                                abs(Difference / Value_Old) * 100)
    )

  cat("=== ERROR VALUE COMPARISON (MATCHING OBSERVATIONS) ===\n")
  cat("Total matching observations:", nrow(comparison), "\n")

  if (nrow(comparison) > 0) {
    cat("Identical values (diff < 0.0001):", sum(comparison$Abs_Difference < 0.0001, na.rm = TRUE), "\n")
    cat("Different values (diff >= 0.0001):", sum(comparison$Abs_Difference >= 0.0001, na.rm = TRUE), "\n\n")

    discrepancies <- comparison %>%
      filter(Abs_Difference >= 0.0001) %>%
      arrange(desc(Abs_Difference))

    if (nrow(discrepancies) > 0) {
      cat("=== DISCREPANCIES (>= 0.0001) ===\n")
      cat("Number of discrepancies:", nrow(discrepancies), "\n\n")
      print(discrepancies %>%
              select(Year, State, Class, Variable, Category, Weighting_Method,
                     Value_Old, Value_New, Difference, Abs_Difference) %>%
              head(20))

      cat("\n\nSummary Statistics:\n")
      cat("Mean absolute difference:", mean(discrepancies$Abs_Difference, na.rm = TRUE), "\n")
      cat("Median absolute difference:", median(discrepancies$Abs_Difference, na.rm = TRUE), "\n")
      cat("Max absolute difference:", max(discrepancies$Abs_Difference, na.rm = TRUE), "\n")

      cat("\nDiscrepancies by Variable:\n")
      print(discrepancies %>% count(Variable, sort = TRUE))

      cat("\nDiscrepancies by Year:\n")
      print(discrepancies %>% count(Year, sort = TRUE))

      cat("\nDiscrepancies by Class:\n")
      print(discrepancies %>% count(Class, sort = TRUE))
    } else {
      cat("✅ ALL MATCHING ERROR VALUES ARE IDENTICAL!\n")
    }
  } else {
    cat("❌ NO MATCHING OBSERVATIONS FOUND!\n")
    cat("\nThis suggests structural differences. Check:\n")
    cat("- Are Class values the same? (should be 'Candidate Choice', 'Demographic', 'Voting')\n")
    cat("- Are Variable names standardized in both?\n")
    cat("- Are you comparing the right tables?\n")
  }

  # ==============================================================================
  # STEP 5: Create output dataframes for inspection
  # ==============================================================================

  missing_from_new_df <- most_specific_long_old %>%
    semi_join(missing_in_new, by = c("Year", "State", "Class", "Variable", "Category", "Weighting_Method")) %>%
    arrange(Year, State, Class, Variable, Category, Weighting_Method)

  extra_in_new_df <- most_specific_long_new %>%
    semi_join(extra_in_new, by = c("Year", "State", "Class", "Variable", "Category", "Weighting_Method")) %>%
    arrange(Year, State, Class, Variable, Category, Weighting_Method)

  discrepancies_df <- if(exists("discrepancies") && nrow(discrepancies) > 0) {
    discrepancies
  } else {
    tibble()
  }

  cat("\n\n=== OUTPUT DATAFRAMES CREATED ===\n")
  cat("View detailed results with:\n")
  cat("- missing_from_new_df:", nrow(missing_from_new_df), "rows (in old but not new)\n")
  cat("- extra_in_new_df:", nrow(extra_in_new_df), "rows (in new but not old)\n")
  cat("- discrepancies_df:", nrow(discrepancies_df), "rows (different error values)\n")

  # ==============================================================================
  # STEP 6: Overall assessment
  # ==============================================================================

  cat("\n\n=== OVERALL ASSESSMENT ===\n")
  if (nrow(missing_in_new) == 0 && nrow(extra_in_new) == 0 && nrow(discrepancies_df) == 0) {
    cat("✅ PERFECT MATCH! New refactored code produces identical results to original.\n")
    cat("   - Same observations (", nrow(old_keys), " each)\n")
    cat("   - Same error values (", nrow(comparison), " compared)\n")
    cat("   - Refactoring successful!\n")
  } else {
    cat("⚠️  DIFFERENCES DETECTED:\n")
    if (nrow(missing_in_new) > 0) {
      cat("   -", nrow(missing_in_new), "observations missing from new code\n")
    }
    if (nrow(extra_in_new) > 0) {
      cat("   -", nrow(extra_in_new), "extra observations in new code\n")
    }
    if (nrow(discrepancies_df) > 0) {
      cat("   -", nrow(discrepancies_df), "observations with different error values\n")
    }
    cat("\nInvestigate using the output dataframes listed above.\n")
  }

  # Return summary for programmatic access
  list(
    summary = tibble(
      old_count = nrow(old_keys),
      new_count = nrow(new_keys),
      missing_from_new = nrow(missing_in_new),
      extra_in_new = nrow(extra_in_new),
      matching = nrow(comparison),
      discrepancies = nrow(discrepancies_df)
    ),
    missing_from_new = missing_from_new_df,
    extra_in_new = extra_in_new_df,
    discrepancies = discrepancies_df
  )


```
## Convert to Long Format (optional)
```{r}
```

## Calculate Summary Statistics
```{r}
# Use most_specific_long for summary statistics (avoids double-counting)

# Calculate RMSE by year and variable
rmse_summary <- most_specific_long %>%
  group_by(Year, Variable, Weighting_Method) %>%
  summarise(
    RMSE = sqrt(mean(Error^2, na.rm = TRUE)),
    n = n(),
    .groups = "drop"
  )

# Calculate RMSE by class
rmse_by_class <- most_specific_long %>%
  group_by(Year, Class, Weighting_Method) %>%
  summarise(
    RMSE = sqrt(mean(Error^2, na.rm = TRUE)),
    n = n(),
    .groups = "drop"
  )

# Calculate RMSE by variable type (Primary vs Secondary)
rmse_by_variable_type <- most_specific_long %>%
  group_by(Year, Variable_Type, Weighting_Method) %>%
  summarise(
    RMSE = sqrt(mean(Error^2, na.rm = TRUE)),
    n = n(),
    .groups = "drop"
  )

# Filter to only Secondary variables (not used in CES weighting)
secondary_only_rmse <- most_specific_long %>%
  filter(Variable_Type == "Secondary") %>%
  group_by(Year, Variable, Weighting_Method) %>%
  summarise(
    RMSE = sqrt(mean(Error^2, na.rm = TRUE)),
    n = n(),
    .groups = "drop"
  )

```
# ==============
#   OLD CODE
# ===============
# Combine into all errors
```{r}
all_errors_wide <- bind_rows(
  party_modal,
  candidate_modal,
  demographic_modal
)
```

--------------------------
## Define PARTY-LEVEL election error workhorse function
```{r}
create_party_error_table <- function(yearly_ces_wt_vars,
                                         election_results_df,
                                         year_data_list,
                                         NC_flag_df) {
  #browser()
  
  # map CES column names to the exact Office labels in election_results_df$Office
  race_map <- c(
    HOUSE_PARTY_rc                 = "US House",
    SENATOR_PARTY_rc               = "US Senate",
    PRES_PARTY_rc                  = "President",
    GOV_PARTY_rc                   = "Governor",
    SECSTATE_PARTY_rc              = "Secretary of State",
    AG_PARTY_rc                    = "Attorney General",
    ST_REP_PARTY_rc                = "State Representative",
    ST_SENATOR_PARTY_rc            = "State Senator"
  )
  
  result_list <- list()
  
    pb <- progress_bar$new(
    format = "Processing :year [:bar] :percent eta: :eta",
    total = length(year_data_list),
    clear = FALSE,
    width = 60
  )
  
  for (year_data in year_data_list) {
    pb$tick(tokens = list(year = year_data$year))
    current_year <- year_data$year
    ces_df <- year_data$CES
    
    # restrict to results for this year
    year_elec <- election_results_df %>% filter(Year == current_year)
    
    # figure out which CES columns we actually have this year
    available_races <- intersect(names(ces_df), names(race_map))
    result_df <- create_empty_result_df()
    
    for (race_col in available_races) {
      # drop NC cases in 2020 if flagged
      if (current_year == 2020 & race_col == "HOUSE_PARTY_rc") {
        ces_df <- ces_df %>%
          filter(!(caseid %in% NC_flag_df$caseid))
      }
      
      office_label <- race_map[[race_col]]
      
      for (state in unique(na.omit(ces_df$POST_STATE_rc))) {
        # This can be uncommented to debug specific states and races
        # if (state == "NEBRASKA" & race_col == "ST_SENATOR_rc") {
        #   browser()
        # }
        
        # SKIP‐LOGIC: bail if this year/race/state is flagged
        skip_row <- skip_conditions %>%
          filter(State == state,
                 Year  == current_year,
                 Race  == race_col,       # or use office_label if your skip_conditions$Race is the full Office name
                 `Skip?` == TRUE)
        if (nrow(skip_row) > 0) next
        state_survey <- ces_df %>% filter(POST_STATE_rc == state)
        n_resp <- sum(!is.na(state_survey[[race_col]]))
        if (n_resp == 0) next
        
        # find the matching election returns
        state_returns <- year_elec %>%
          filter(State == state, Office == office_label)
        if (nrow(state_returns) == 0) {
          stop(glue::glue("No election results for {office_label}, {state}, {current_year}, {race_col}"))
        }
        
        # compute weighted proportions
        wt_var <- yearly_ces_wt_vars[[ as.character(current_year) ]][1]
        ces_wt   <- wpct(state_survey[[race_col]], weight = state_survey[[wt_var]], na.rm = TRUE)
        ces_unwt <- wpct(state_survey[[race_col]], na.rm = TRUE)
        anes_wt  <- wpct(state_survey[[race_col]], weight = state_survey$anesrake_weight, na.rm = TRUE)
        
        # ensure all three parties
        for (lvl in c("Democrat","Republican","Other")) {
          if (lvl %notin% names(ces_wt))   ces_wt[lvl]   <- 0
          if (lvl %notin% names(ces_unwt)) ces_unwt[lvl] <- 0
          if (lvl %notin% names(anes_wt))  anes_wt[lvl]  <- 0
        }
        ces_wt   <- ces_wt[c("Democrat","Republican","Other")]
        ces_unwt <- ces_unwt[c("Democrat","Republican","Other")]
        anes_wt  <- anes_wt[c("Democrat","Republican","Other")]
        
        # true proportions
        true_vec <- c(
          Democrat  = state_returns$DEM_Proportion,
          Republican= state_returns$REP_Proportion,
          Other     = state_returns$OTHER_Proportion
        )
        
        # compute diffs
        diff_ces   <- ces_wt   - true_vec
        diff_unwt  <- ces_unwt - true_vec
        diff_anes  <- anes_wt  - true_vec
        
        # stack into rows
        for (party in names(true_vec)) {
          result_df <- bind_rows(
            result_df,
            tibble(
              Year                         = current_year,
              Race                         = office_label,
              State                        = state,
              CES_Candidate                = "Grouped Candidates",
              True_Candidate               = "Grouped Candidates",
              CES_Party                    = party,
              True_Party                   = party,
              Actual_Percent               = true_vec[party] * 100,
              CES_Unweighted_Percent       = ces_unwt[party] * 100,
              CES_Weighted_Percent         = ces_wt[party]   * 100,
              ANESRake_Weighted_Percent    = anes_wt[party]  * 100,
              Error_CES_Unweighted         = diff_unwt[party] * 100,
              Error_CES_Weighted           = diff_ces[party]   * 100,
              Error_CES_ANESRake_Weighted  = diff_anes[party]  * 100,
              n_respondents                = n_resp
            )
          )
        }
      }
    }
    
    result_list[[as.character(current_year)]] <- result_df
  }
  
  bind_rows(result_list)
}

```

## Call PARTY-LEVEL workhorse function
Create election error table, then clean it up and split it into a list of yearly error tables with make_tables_pretty
```{r}
party_level_election_error_table <- create_party_error_table(
  yearly_ces_wt_vars,
  merged_prop_tables_combined,
  list_all_years,
  NC_flag_df
)

party_level_election_error_table_pretty <- make_tables_pretty(party_level_election_error_table)
```

## Define modal CANDIDATE-LEVEL election error workhorse function
While the party-level workhorse function computes error for all parties and then modalizes later, for candidate-level, the primary workhorse function only calculates error for the modal candidate. Name-matching is error prone, so it's better to try to match just one name per election.
```{r}
create_modal_candidate_error_table <- function(yearly_ces_wt_vars,
                                               merged_candidate_level_props,
                                               year_data_list,
                                               NC_flag_df) {
  
  race_map <- c(
    PRES_CANDIDATE_rc    = "President",
    SENATOR_CANDIDATE_rc = "US Senate",
    HOUSE_CANDIDATE_rc   = "US House",
    GOV_CANDIDATE_rc     = "Governor",
    SECSTATE_CANDIDATE_rc= "Secretary of State",
    AG_CANDIDATE_rc      = "Attorney General"
  )
  #browser()

  result_list <- list()

  pb <- progress_bar$new(
    format = "Measuring error in :year [:bar] :percent eta: :eta",
    total = length(year_data_list),
    clear = FALSE,
    width = 60
  )

  for (year_data in year_data_list) {
    pb$tick(tokens = list(year = year_data$year))
    current_year <- year_data$year
    if (current_year %in% c("2006", "2008")) {
      # Skip 2006 and 2008 because they don't have candidate-level data
      next
    }

    ces_df <- year_data$CES

    ces_cols <- intersect(names(ces_df), names(race_map))
    result_df <- tibble()

    for (race_col in ces_cols) {
      if (current_year == 2020 & race_col == "HOUSE_CANDIDATE_rc") {
        ces_df <- ces_df %>% filter(!(caseid %in% NC_flag_df$caseid))
      }

      office_label <- race_map[[race_col]]

      for (state in unique(na.omit(ces_df$POST_STATE_rc))) {
        skip_row <- skip_conditions %>%
          filter(State == state, Year == current_year, Race == race_col, `Skip?` == TRUE)
        if (nrow(skip_row) > 0) next

        # Subset state survey
        state_df <- ces_df %>% filter(POST_STATE_rc == state)
        
        ## For debugging
        #print(glue::glue("Processing {current_year}, {office_label}, {state}"))
        # if (current_year == 2010 & office_label == "US Senate" & state == "ALASKA") {
        #   browser()
        # }

        # If US House, loop over districts; otherwise, just one iteration
        districts <- if (office_label == "US House") {
          unique(na.omit(state_df$CDID_post_rc))
        } else if (office_label == "President") {
          "nationwide"
        } else {
          "statewide"
        }
        
        # If the office is not US House, we only have one district
        for (district in districts) {
          
          if (district %notin% c("statewide", "nationwide")) {
            state_district_survey <- state_df %>% filter(CDID_post_rc == district)
          } else {
            state_district_survey <- state_df
          }

          n_resp <- sum(!is.na(state_district_survey[[race_col]]))
          if (n_resp == 0) next

          # Select election returns
          state_district_returns <- merged_candidate_level_props %>%
            filter(
              Year == current_year,
              State == state,
              Office == office_label,
              District == district
            )
          if (nrow(state_district_returns) == 0) next
          
          
          # Make special case for 2010 U.S. Senate race for Alaska, where 
          # Lisa Murkowski won as a write-in
          if (current_year == 2010 & office_label == "US Senate" & state == "ALASKA") {
          top_cand <- state_district_returns %>%
            filter(Candidate == "JOE MILLER")
          }
          else {
            top_cand <- state_district_returns %>%
              slice_max(Proportion, n = 1, with_ties = FALSE)
          }

          # Find the top candidate in the election returns
          true_cand <- (top_cand$Candidate)
          true_prop <- top_cand$Proportion * 100

          ces_vals_raw  <- unique(na.omit(state_district_survey[[race_col]]))
          ces_vals <- (ces_vals_raw)
         
          # Fuzzy Candidate Name Matching
          # Case-insensitive exact match check
          exact_match_found <- any(stri_trans_tolower(true_cand) == stri_trans_tolower(ces_vals))
          
          if (!exact_match_found) {
            # Fuzzy match using case-insensitive inputs
            match_scores <- stringdist::stringdist(stri_trans_tolower(true_cand),
                                                   stri_trans_tolower(ces_vals),
                                                   method = "jw")
            matched_ces <- ces_vals[which.min(match_scores)]  # Return original-cased name
            matched_score <- min(match_scores)
          } else {
            # Exact match (case-insensitive) — get the original-cased name from ces_vals
            matched_ces <- ces_vals[stri_trans_tolower(ces_vals) == stri_trans_tolower(true_cand)][1]
            matched_score <- 0
          }
          
          # Find corresponding party with matches CES candidate
          if (race_col != "PRES_CANDIDATE_rc") {
              party_col <- sub("_CANDIDATE_rc$", "_PARTY_rc", race_col)
          }
          else{
              party_col <- "PRES_CANDIDATE_rc"
          }
          
          if (!party_col %in% names(state_district_survey)) {
            stop(glue::glue("Missing expected party column {party_col} in CES data for {state}, {current_year}, {race_col}"))
          }
          
          # Find the party associated with the matched CES candidate
          party_val <- state_district_survey %>%
            transmute(
              .cand  = .data[[race_col]],
              .party = .data[[party_col]]
            ) %>%
            filter(stri_trans_casefold(.cand) == stri_trans_casefold(matched_ces)) %>%
            distinct(.party) %>%
            pull(.party)
          
          if (length(party_val) != 1) {
            stop(glue::glue("Matched CES candidate {matched_ces} in {state}, {current_year}, {race_col} has {length(party_val)} unique party values: {toString(party_val)} when it should be just 1"))
          }
          
          ces_party <- party_val

          wt_var <- yearly_ces_wt_vars[[as.character(current_year)]][1]

          ces_wt   <- wpct(state_district_survey[[race_col]], weight = state_district_survey[[wt_var]], na.rm = TRUE)
          ces_unwt <- wpct(state_district_survey[[race_col]], na.rm = TRUE)
          anes_wt  <- wpct(state_district_survey[[race_col]], weight = state_district_survey$anesrake_weight, na.rm = TRUE)

          wt_val   <- ces_wt[matched_ces]   * 100
          unwt_val <- ces_unwt[matched_ces] * 100
          anes_val <- anes_wt[matched_ces]  * 100
          
          # For debugging
          other_cands <- setdiff(ces_vals, matched_ces)
          other_cands <- str_to_title(other_cands)

          result_df <- bind_rows(
            result_df,
            tibble(
              Year                         = current_year,
              Race                         = office_label,
              State                        = state,
              District                     = district,
              CES_Candidate                = str_to_title(matched_ces),
              True_Candidate               = str_to_title(true_cand),
              Other_CES_Candidate_Options  = list(other_cands),
              Matching_Distance_Score      = matched_score,
              CES_Party                    = ces_party,
              True_Party                   = top_cand$Party_Detailed,
              Actual_Percent               = true_prop,
              CES_Unweighted_Percent       = unwt_val,
              CES_Weighted_Percent         = wt_val,
              ANESRake_Weighted_Percent    = anes_val,
              Error_CES_Unweighted         = unwt_val - true_prop,
              Error_CES_Weighted           = wt_val   - true_prop,
              Error_CES_ANESRake_Weighted  = anes_val - true_prop,
              n_respondents                = n_resp
            )
          )
        }
      }
    }

    result_list[[as.character(current_year)]] <- result_df
  }

  bind_rows(result_list)
}

```


## Call CANDIDATE-LEVEL workhorse function
```{r}
modal_candidate_error_table <- create_modal_candidate_error_table(
  yearly_ces_wt_vars,
  merged_candidate_level_props,
  list_all_years,
  NC_flag_df
)
```


# Compute "Demoplus" Errors
Calculate error for demographics plus a few other variables ("demoplus") like turnout and voting method.
```{r}
demoplus_comparison_vars <- c("SEX_rc", "EDUC_rc", "VETSTAT_rc", "EMPSTAT_rc", "UNION_rc", "REGION_rc", "AGE_GROUP_rc", "VOTED_rc", "VOTEHOW_rc", "CITIZEN_rc", "HISPAN_rc", "FAMINC_rc")

yearly_ces_wtvar_names_shortened <- list(
  "2006" = c("v1001", "anesrake_weight"),
  "2008" = c("V201", "anesrake_weight"),
  "2010" = c("V101", "anesrake_weight"),
  "2012" = c("V103", "anesrake_weight"),
  "2014" = c("weight", "anesrake_weight"),
  "2016" = c("commonweight_post", "anesrake_weight"),
  "2018" = c("commonpostweight", "anesrake_weight"),
  "2020" = c("commonpostweight","anesrake_weight"),
  "2022" = c("commonpostweight", "anesrake_weight"))
```

## Define workhorse demoplus error function
```{r}
calculate_demoplus_error <- function(year_data, year) {
  ces_df <- year_data$CES
  cps_df <- year_data$CPS
  weight_vars <- yearly_ces_wtvar_names_shortened[[as.character(year)]]

  all_results <- list()

  for (state in unique(na.omit(ces_df$POST_STATE_rc))) {
    # message("Processing state: ", state)

    ces_state <- filter(ces_df, POST_STATE_rc == state)
    cps_state <- filter(cps_df, POST_STATE_rc == state)

    for (demo_var in demoplus_comparison_vars) {
      # message("  Variable: ", demo_var)

      # Skip if missing in either
      if (!(demo_var %in% names(ces_state)) || !(demo_var %in% names(cps_state))) {
        # message("  ✖ Skipped (missing in dataset): ", demo_var)
        next
      }

      # Harmonize levels
      categories <- sort(unique(c(ces_state[[demo_var]], cps_state[[demo_var]])))
      categories <- categories[!is.na(categories)]

      # Compute proportions
      cps_props <- prop.table(table(factor(cps_state[[demo_var]], levels = categories))) * 100
      ces_unweighted_props <- prop.table(table(factor(ces_state[[demo_var]], levels = categories))) * 100
      ces_weighted_props <- weighted_prop_zero(ces_state[[demo_var]], ces_state[[weight_vars[1]]], levels = categories) * 100
      ces_anesrake_weighted_props <- weighted_prop_zero(ces_state[[demo_var]], ces_state[[weight_vars[2]]], levels = categories) * 100

      # Combine results
      demo_results <- data.frame(
        Year = year,
        State = state,
        Variable = demo_var,
        Category = names(cps_props),
        CPS = as.numeric(cps_props),
        CES_Unweighted = as.numeric(ces_unweighted_props),
        CES_Weighted = as.numeric(ces_weighted_props),
        CES_ANESRake_Weighted = as.numeric(ces_anesrake_weighted_props),
        stringsAsFactors = FALSE
      )
      
      demo_results <- data.frame(
        Year = year,
        State = state,
        Variable = demo_var,
        Category = names(cps_props),
        CPS = as.numeric(cps_props),
        CES_Unweighted = as.numeric(ces_unweighted_props),
        CES_Weighted = as.numeric(ces_weighted_props),
        CES_ANESRake_Weighted = as.numeric(ces_anesrake_weighted_props),
        stringsAsFactors = FALSE
      ) %>%
        mutate(
          Error_CES_Weighted = CPS - CES_Weighted,
          Error_CES_Unweighted = CPS - CES_Unweighted,
          Error_CES_ANESRake_Weighted = CPS - CES_ANESRake_Weighted
        )
      
      all_results[[length(all_results) + 1]] <- demo_results
    }
  }

  bind_rows(all_results)
}
```

## Call workhorse function
Note: This will tell you that a lot of variables are skipped because they're missing in the dataset. That's ok - it's just because the CES didn't collect some variables in certain years (but did in others).
```{r}
# Computes error for non candidate choice variables across all years
demoplus_error_table <- map2_dfr(
  .x = list_all_years,
  .y = map_chr(list_all_years, ~ as.character(.x$year)),
  .f = calculate_demoplus_error
)
```



```{r}
  # Diagnostic script to find differences in Variables between demoplus_error_table and demovote_errors

  # Get unique State/Year/Variable combinations from each
  # Convert Year to character for consistent comparison
  table_combos <- demoplus_error_table %>%
    mutate(Year = as.character(Year)) %>%
    distinct(Year, State, Variable) %>%
    arrange(Year, State, Variable)

  errors_combos <- demovote_errors %>%
    mutate(Year = as.character(Year)) %>%
    distinct(Year, State, Variable) %>%
    arrange(Year, State, Variable)

  # Find what's in demoplus_error_table but NOT in demovote_errors
  in_table_not_errors <- anti_join(
    table_combos,
    errors_combos,
    by = c("Year", "State", "Variable")
  )

  # Find what's in demovote_errors but NOT in demoplus_error_table
  in_errors_not_table <- anti_join(
    errors_combos,
    table_combos,
    by = c("Year", "State", "Variable")
  )

  # Compare counts
  cat("Total unique Year/State/Variable combos in demoplus_error_table:", nrow(table_combos), "\n")
  cat("Total unique Year/State/Variable combos in demovote_errors:", nrow(errors_combos), "\n")
  cat("Difference:", abs(nrow(table_combos) - nrow(errors_combos)), "\n\n")

  cat("Combos in demoplus_error_table but NOT in demovote_errors:\n")
  print(in_table_not_errors)

  cat("\n\nCombos in demovote_errors but NOT in demoplus_error_table:\n")
  print(in_errors_not_table)

  # Also check if there are differences in row counts per combo
  rowcount_comparison <- full_join(
    demoplus_error_table %>% mutate(Year = as.character(Year)) %>% count(Year, State, Variable, name =
  "n_table"),
    demovote_errors %>% mutate(Year = as.character(Year)) %>% count(Year, State, Variable, name = "n_errors"),
    by = c("Year", "State", "Variable")
  ) %>%
    mutate(
      n_table = replace_na(n_table, 0),
      n_errors = replace_na(n_errors, 0),
      difference = n_table - n_errors
    ) %>%
    filter(difference != 0)

  cat("\n\nYear/State/Variable combos with different row counts:\n")
  print(rowcount_comparison)
```

ˆ
# Reshaping and Combining Errors
At this point, there's 3 sets of errors: candidate choice at the party level, candidate level, and then demographic-plus vars. Errors for candidate choice at the party level and demographic-plus variables have been computed and stored in separate tables. These tables now need to be filtered to retain only modal categories, reshaped to a long format, and combined into a unified table of all accuracy variables.

## Reshaping and modalizing party-level candidate choice
```{r}
# Bind all years of candidate choice error into one big df
party_level_election_error_table_pretty_binded <- bind_rows(party_level_election_error_table_pretty)

# pivot_longer on the three error‐columns
# (takes error columns and turns them into rows)
party_level_election_error_table_pretty_binded_long <- party_level_election_error_table_pretty_binded %>%
  pivot_longer(
    cols = starts_with("Error"),
    names_to  = "Weighting_Method",
    values_to = "Value"
  ) %>%
  
  # map the ugly column names to clean method labels
  mutate(
    Weighting_Method = case_when(
      grepl("CES_Unweighted", Weighting_Method) ~ "CES-Unweighted",
      grepl("CES_Weighted", Weighting_Method) ~ "CES-Provided Weights",
      grepl("ANESRake", Weighting_Method) ~ "ANESRake",
     TRUE ~ "ERROR"
    ),
    Category = CES_Party,
  ) %>%
  
  select(
    Year, Race, State,
    Weighting_Method, Value,
    everything()
  )

modal_party_rows <- party_level_election_error_table_pretty_binded_long %>%
  group_by(Year, State, Race) %>%
  slice_max(order_by = Actual_Percent, n = 1, with_ties = FALSE) %>%
  ungroup()

modal_party_level_election_error_table_pretty_binded_long <- party_level_election_error_table_pretty_binded_long %>%
  semi_join(modal_party_rows, by = c("Year", "State", "Race", "CES_Party")) %>%
  mutate(Metric = "Modal Error")
```

## Reshaping and modalizing demoplus variables
```{r}
# For each demographic variable within each state and year, retain only the modal category based on CPS proportions
modal_demoplus_error_table <- demoplus_error_table %>%
  group_by(Year, State, Variable) %>%
  slice_max(order_by = CPS, n = 1, with_ties = FALSE) %>%
  ungroup() %>%
  mutate(Year = as.numeric(Year))

# Turn modal summary table into "long" table
modal_demoplus_error_table_long <- modal_demoplus_error_table %>%
  pivot_longer(
    cols = starts_with("Error"),
    names_to = "Weighting_Method",
    values_to = "Value"
  ) %>%
  mutate(
    Weighting_Method = case_when(
      grepl("CES_Unweighted", Weighting_Method) ~ "CES-Unweighted",
      grepl("CES_Weighted", Weighting_Method) ~ "CES-Provided Weights",
      grepl("ANESRake", Weighting_Method) ~ "ANESRake",
      TRUE ~ NA
    ),
    Metric = "Modal Error",
    Variable = Variable,
    Category = Category,
  ) %>%
  select(Year, State, Weighting_Method, Metric, Value, Variable, Category, everything())

```

## Combine party level candidate choice and demoplus tables
```{r}
var_map <- c(
  "US Senate"        = "U.S. Senate",
  "US House"         = "U.S. House",
  "President"        = "President",
  "Governor"         = "Governor",
  "AGE_GROUP_rc"     = "Age Group",
  "EDUC_rc"          = "Education",
  "EMPSTAT_rc"       = "Employment Status",
  "FAMINC_rc"        = "Family Income",
  "REGION_rc"        = "Region",
  "SEX_rc"           = "Sex",
  "UNION_rc"         = "Union Membership",
  "VETSTAT_rc"       = "Veteran Status",
  "VOTED_rc"         = "Voting Turnout",
  "VOTEHOW_rc"       = "Voting Method",
  "HISPAN_rc"        = "Hispanic Origin",
  "CITIZEN_rc"       = "Citizenship Status"
)

standardize_variable_names <- function(df) {
  df %>% dplyr::mutate(Variable = dplyr::recode(Variable, !!!var_map, .default = Variable))
}

# Build harmonized tables and standardize variable names inside each
modal_party_level_harmonized <- modal_party_level_election_error_table_pretty_binded_long %>%
  mutate(
    Variable  = Race,
    Category  = CES_Party,
    Benchmark = Actual_Percent,
    Class     = "Candidate Choice"
  ) %>%
  select(
    Year, State, Class, Variable, Category,
    Weighting_Method, Metric, Value, Benchmark,
    CES_Unweighted, CES_Weighted, CES_ANESRake_Weighted,
    n_respondents
  ) %>%
  standardize_variable_names()

modal_demoplus_harmonized <- modal_demoplus_error_table_long %>%
  mutate(
    n_respondents = NA_integer_,
    Benchmark = CPS,
    Class = case_when(
      Variable %in% c("VOTED_rc", "VOTEHOW_rc") ~ "Voting",
      TRUE ~ "Demographic"
    )
  ) %>%
  select(
    Year, State, Class, Variable, Category, Weighting_Method,
    Metric, Value, Benchmark,
    CES_Unweighted, CES_Weighted, CES_ANESRake_Weighted,
    n_respondents
  ) %>%
  standardize_variable_names()

# combine
modal_party_level_demoplus_error_table_all <- bind_rows(
  modal_party_level_harmonized,
  modal_demoplus_harmonized
)
```

## Combine candidate level candidate choice and demoplus tables
```{r}
modal_candidate_harmonized <- modal_candidate_error_table %>%
  mutate(
    Variable = Race,                       # start from Race
    Category  = CES_Party,
    Benchmark = Actual_Percent,
    Class     = "Candidate Choice",
    CES_Unweighted        = CES_Unweighted_Percent,
    CES_Weighted          = CES_Weighted_Percent,
    CES_ANESRake_Weighted = ANESRake_Weighted_Percent
  ) %>%
  # standardize names
  standardize_variable_names() %>%
  # append district for House (after standardization so base matches exactly "U.S. House")
  mutate(
    Variable = dplyr::if_else(
      Variable == "U.S. House" & !is.na(District) &
        District != "statewide" & District != "nationwide",
      paste0("U.S. House (", District, ")"),
      Variable
    )
  ) %>%
  select(
    Year, State, Class, Variable, Category, CES_Candidate,
    Benchmark,
    CES_Unweighted, CES_Weighted, CES_ANESRake_Weighted,
    n_respondents,
    dplyr::starts_with("Error_")
  ) %>%
  tidyr::pivot_longer(
    cols = dplyr::starts_with("Error_"),
    names_to  = "Weighting_Method",
    values_to = "Value"
  ) %>%
  mutate(
    Weighting_Method = dplyr::case_when(
      grepl("Unweighted", Weighting_Method) ~ "CES-Unweighted",
      grepl("ANESRake",   Weighting_Method) ~ "ANESRake",
      grepl("Weighted",   Weighting_Method) ~ "CES-Provided Weights",
      TRUE ~ Weighting_Method
    ),
    Metric = "Modal Error"
  ) %>%
  select(
    Year, State, Class, Variable, Category, CES_Candidate,
    Weighting_Method, Metric, Value, Benchmark,
    CES_Unweighted, CES_Weighted, CES_ANESRake_Weighted,
    n_respondents
  )

# Combine
modal_candidate_level_demoplus_error_table_all <- dplyr::bind_rows(
  standardize_variable_names(modal_demoplus_harmonized),
  modal_candidate_harmonized
)

```


## Create "most specific available" error table
Importantly, candidate-level data was not available in all years, so the candidate-level + demoplus combined table is actually missing some years of AG, and all years of state house and state senate. So, I construct a table that is "the most specific data available" for each variable, which might mean candidate-level for some variables and party-level for others.

```{r}
# Ensure party-level+demoplus table has CES_Candidate for schema parity
modal_party_level_demoplus_error_table_all_pad <- modal_party_level_demoplus_error_table_all %>%
  mutate(CES_Candidate = NA_character_)

# One copy of Demo/Voting rows
demo_keep <- modal_demoplus_harmonized %>%
  mutate(CES_Candidate = NA_character_)

# Candidate-choice variables universe
final_cand_choice_vars <- c(
  "President","U.S. Senate","U.S. House","Governor",
  "Secretary of State","Attorney General","State Senator","State Representative"
)

# Candidate-level keepers by year rules
cand_keep <- bind_rows(
  # 2010–2016: candidate-level for Pres/Sen/House/Gov
  modal_candidate_level_demoplus_error_table_all %>%
    filter(Class == "Candidate Choice",
           Year >= 2010, Year <= 2016,
           Variable %in% c("President","U.S. Senate","U.S. House","Governor")),
  # 2018–2022: candidate-level adds SecState + AG
  modal_candidate_level_demoplus_error_table_all %>%
    filter(Class == "Candidate Choice",
           Year >= 2018, Year <= 2022,
           Variable %in% c("President","U.S. Senate","U.S. House","Governor",
                           "Secretary of State","Attorney General"))
)

# Party-level fallback by year rules
party_keep <- bind_rows(
  # 2006 & 2008: all candidate-choice from party-level
  modal_party_level_demoplus_error_table_all_pad %>%
    filter(Class == "Candidate Choice",
           Year %in% c(2006, 2008),
           Variable %in% final_cand_choice_vars),
  # 2010–2016: party-level for SecState, AG, State Leg
  modal_party_level_demoplus_error_table_all_pad %>%
    filter(Class == "Candidate Choice",
           Year >= 2010, Year <= 2016,
           Variable %in% c("Secretary of State","Attorney General",
                           "State Senator","State Representative")),
  # 2018–2022: party-level only for State Leg
  modal_party_level_demoplus_error_table_all_pad %>%
    filter(Class == "Candidate Choice",
           Year >= 2018, Year <= 2022,
           Variable %in% c("State Senator","State Representative"))
)

# Final: most-specific-available modal table
most_specific_modal_error_table_all <- bind_rows(
  demo_keep,
  cand_keep,
  party_keep
) %>%
  arrange(Year, State, Class, Variable, Category, Weighting_Method)
```

# Results
Now that an error table has been created, subset that table to compute RMSE and report various other breakdowns of error. Outputs are excel sheets that serve as inputs to figuresHQ.ipynb


Big overall summary table, rows are years, columns are variables, values are RMSE
-- For candidate level + demoplus vars
```{r}
secondary_variables <- c(
  #These are the variables that can be used for assessing accuracy, since they
  # were not used in any post-stratification process (excludes president, governor, us senate, age, sex, race, education)
  "U.S. House",
  "Attorney General",
  "Secretary of State",
  "State Senator",
  "State Representative",
  "Employment Status",
  "Family Income",
  "Region",
  "Union Membership",
  "Hispanic Origin",
  "Citizenship Status",
  "Veteran Status",
  "Voting Turnout",
  "Voting Method"
)

ces_wtd_rmse_summary_table <- most_specific_modal_error_table_all %>%
  filter(Weighting_Method == "CES-Provided Weights",
         Variable %in% secondary_variables) %>%
  group_by(Year, Variable) %>%
  summarise(RMSE = sqrt(mean(Value^2, na.rm = TRUE)), .groups = "drop") %>%
  pivot_wider(
    names_from = Variable,
    values_from = RMSE
  ) %>%
  select(Year, all_of(secondary_variables)) %>%
  mutate(Year = as.character(Year)) %>%
  mutate(`Year Average` = rowMeans(across(all_of(secondary_variables)), na.rm = TRUE)) %>%
  bind_rows(
    summarise(
      .,
      Year = "Variable Average",
      across(all_of(secondary_variables), ~ mean(.x, na.rm = TRUE)),
      `Year Average` = mean(`Year Average`, na.rm = TRUE)
    )
  )

write_xlsx(
  ces_wtd_rmse_summary_table,
  here("tables_and_figures/input tables", "ces_wtd_rmse_summary_table.xlsx")
)

```

Distribution of errors
```{r}
dist_errors_bucket_table <- most_specific_modal_error_table_all %>%
  mutate(
    Abs_Error = abs(Value),
    Error_Bucket = cut(
      Abs_Error,
      breaks = seq(0, ceiling(max(Abs_Error, na.rm = TRUE)), by = 1),
      right = FALSE,
      include.lowest = TRUE
    )
  ) %>%
  group_by(Class, Weighting_Method, Error_Bucket) %>%
  summarise(
    Count = n(),
    .groups = "drop"
  )

write_xlsx(
  dist_errors_bucket_table,
  here("tables_and_figures/input tables", "dist_errors_bucket_table.xlsx")
)
```

Yearly RMSE by Weighting Method
```{r}
rmse_by_weighting_method <- most_specific_modal_error_table_all %>%
  filter(Variable %in% secondary_variables) %>% 
  group_by(Year, Variable, Weighting_Method) %>%
  summarise(RMSE = sqrt(mean(Value^2, na.rm = TRUE)), .groups = "drop") %>%
  group_by(Year, Weighting_Method) %>%
  summarise(Avg_RMSE = mean(RMSE, na.rm = TRUE), .groups = "drop")

write_xlsx(
  rmse_by_weighting_method,
  here("tables_and_figures/input tables", "rmse_by_weighting_method.xlsx")
)
```

Yearly RMSE by Weighting Method and Class
```{r}
rmse_by_weighting_method_and_class <- most_specific_modal_error_table_all %>%
  filter(Variable %in% secondary_variables)

# RMSE by Class
rmse_by_class <- rmse_by_weighting_method_and_class %>%
  group_by(Year, Variable, Weighting_Method, Class) %>%
  summarise(RMSE = sqrt(mean(Value^2, na.rm = TRUE)), .groups = "drop") %>%
  group_by(Year, Weighting_Method, Class) %>%
  summarise(Avg_RMSE = mean(RMSE, na.rm = TRUE), .groups = "drop")

# RMSE over all classes (rollup)
rmse_all <- rmse_by_weighting_method_and_class %>%
  group_by(Year, Variable, Weighting_Method) %>%
  summarise(RMSE = sqrt(mean(Value^2, na.rm = TRUE)), .groups = "drop") %>%
  group_by(Year, Weighting_Method) %>%
  summarise(Avg_RMSE = mean(RMSE, na.rm = TRUE), .groups = "drop") %>%
  mutate(Class = "All")

# Combine and save
rmse_by_weighting_method <- bind_rows(rmse_by_class, rmse_all) %>%
  arrange(Year, Weighting_Method, Class)

write_xlsx(
  rmse_by_weighting_method,
  here("tables_and_figures/input tables", "rmse_by_weighting_method_and_class.xlsx")
)

```


Candidate choice accuracy by race competitiveness
```{r}
competitiveness_bins <- tribble(
  ~Range_Label, ~Lower, ~Upper,
  "0-100%",      0,      100,
  "30-70%",     30,       70,
  "40-60%",     40,       60,
  "45-55%",     45,       55,
  "80-100%",    95,      100
)

election_rmse_by_competitiveness_range <- most_specific_modal_error_table_all %>%
  filter(Class == "Candidate Choice") %>%
  crossing(competitiveness_bins) %>%
  filter(Benchmark >= Lower, Benchmark <= Upper) %>%
  group_by(Year, Party = Category, Weighting_Method, Range_Label) %>%
  summarise(
    RMSE = sqrt(mean(Value^2, na.rm = TRUE)),
    Avg_Abs_Error = mean(abs(Value), na.rm = TRUE),
    .groups = "drop"
  )

write_xlsx(
  election_rmse_by_competitiveness_range,
  here("tables_and_figures/input tables", "election_rmse_by_competitiveness_range.xlsx")
)
```

```{r}
calculate_turnout_comparison <- function(year_data, year) {
  ces_df <- year_data$CES
  cps_df <- year_data$CPS
  weight_vars <- yearly_ces_wtvar_names_shortened[[as.character(year)]]
  
  all_results <- list()
  
  for (state in unique(na.omit(ces_df$POST_STATE_rc))) {
    ces_state <- filter(ces_df, POST_STATE_rc == state)
    cps_state <- filter(cps_df, POST_STATE_rc == state)
    
    # Check if VOTED_rc exists in both datasets
    if (!("VOTED_rc" %in% names(ces_state)) || !("VOTED_rc" %in% names(cps_state))) {
      next
    }

    # Get state turnout from turnout_statewide
    state_turnout <- turnout_statewide %>%
      filter(State == state) %>%
      pull(as.character(year))
    
    # Convert to numeric and handle if missing
    state_turnout <- ifelse(length(state_turnout) > 0, 
                           as.numeric(state_turnout) * 100, 
                           NA_real_)
    
    # Calculate turnout proportions (proportion who "Voted")
    cps_turnout <- mean(cps_state$VOTED_rc == "Voted", na.rm = TRUE) * 100
    ces_unweighted_turnout <- mean(ces_state$VOTED_rc == "Voted", na.rm = TRUE) * 100
    ces_weighted_turnout <- weighted.mean(ces_state$VOTED_rc == "Voted", 
                                          ces_state[[weight_vars[1]]], 
                                          na.rm = TRUE) * 100
    ces_anesrake_weighted_turnout <- weighted.mean(ces_state$VOTED_rc == "Voted", 
                                                   ces_state[[weight_vars[2]]], 
                                                   na.rm = TRUE) * 100
    
    # Combine results
    turnout_results <- data.frame(
      Year = year,
      State = state,
      State_Turnout = state_turnout,
      CPS = cps_turnout,
      CES_Unweighted = ces_unweighted_turnout,
      CES_Weighted = ces_weighted_turnout,
      CES_ANESRake_Weighted = ces_anesrake_weighted_turnout,
      stringsAsFactors = FALSE
    )
    
    all_results[[length(all_results) + 1]] <- turnout_results
  }
  
  bind_rows(all_results)
}

# Call the function
turnout_comparison_table <- map2_dfr(
  .x = list_all_years,
  .y = map_chr(list_all_years, ~ as.character(.x$year)),
  .f = calculate_turnout_comparison
)

# export to excel
write_xlsx(
  turnout_comparison_table,
  here("tables_and_figures/input tables", "turnout_comparison_table.xlsx")
)
```

```{r}
# Load required libraries
library(tidyverse)
library(ggplot2)

# 1. Average turnout by source across all years
turnout_summary <- turnout_comparison_table %>%
  group_by(Year) %>%
  summarise(
    State_Turnout = mean(State_Turnout, na.rm = TRUE),
    CPS = mean(CPS, na.rm = TRUE),
    CES_Unweighted = mean(CES_Unweighted, na.rm = TRUE),
    CES_Weighted = mean(CES_Weighted, na.rm = TRUE),
    CES_ANESRake_Weighted = mean(CES_ANESRake_Weighted, na.rm = TRUE)
  ) %>%
  pivot_longer(
    cols = -Year,
    names_to = "Source",
    values_to = "Turnout"
  )

# Plot 1: Line plot showing turnout trends over time
p1 <- ggplot(turnout_summary, aes(x = Year, y = Turnout, color = Source, group = Source)) +
  geom_line(linewidth = 1) +
  geom_point(size = 3) +
  labs(
    title = "Average Turnout Across All States by Source",
    subtitle = "Comparison of State Records, CPS, and CES Estimates",
    x = "Year",
    y = "Turnout (%)",
    color = "Source"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")

print(p1)

# Plot 3: Error/bias visualization (difference from state official records)
error_summary <- turnout_comparison_table %>%
  mutate(
    Error_CPS = CPS - State_Turnout,
    Error_CES_Unweighted = CES_Unweighted - State_Turnout,
    Error_CES_Weighted = CES_Weighted - State_Turnout,
    Error_CES_ANESRake = CES_ANESRake_Weighted - State_Turnout
  ) %>%
  group_by(Year) %>%
  summarise(
    CPS = mean(Error_CPS, na.rm = TRUE),
    CES_Unweighted = mean(Error_CES_Unweighted, na.rm = TRUE),
    CES_Weighted = mean(Error_CES_Weighted, na.rm = TRUE),
    CES_ANESRake_Weighted = mean(Error_CES_ANESRake, na.rm = TRUE)
  ) %>%
  pivot_longer(
    cols = -Year,
    names_to = "Source",
    values_to = "Bias"
  )

p3 <- ggplot(error_summary, aes(x = Year, y = Bias, color = Source, group = Source)) +
  geom_line(linewidth = 1) +
  geom_point(size = 3) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray50") +
  labs(
    title = "Survey Bias Relative to Official State Turnout",
    subtitle = "Positive values = overestimate, Negative values = underestimate",
    x = "Year",
    y = "Bias (percentage points)",
    color = "Source"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")

print(p3)

# Plot 4: Scatterplot comparing CPS vs CES weighted
p4 <- ggplot(turnout_comparison_table, 
             aes(x = CPS, y = CES_Weighted)) +
  geom_point(alpha = 0.5, size = 2) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red") +
  facet_wrap(~Year) +
  labs(
    title = "CPS vs CES Weighted Turnout Estimates",
    subtitle = "Each point is a state; dashed line shows perfect agreement",
    x = "CPS Turnout (%)",
    y = "CES Weighted Turnout (%)"
  ) +
  theme_minimal()

print(p4)

# Plot 5: Summary statistics table
summary_stats <- turnout_comparison_table %>%
  summarise(
    across(
      c(State_Turnout, CPS, CES_Unweighted, CES_Weighted, CES_ANESRake_Weighted),
      list(
        Mean = ~mean(., na.rm = TRUE),
        SD = ~sd(., na.rm = TRUE),
        Min = ~min(., na.rm = TRUE),
        Max = ~max(., na.rm = TRUE)
      ),
      .names = "{.col}_{.fn}"
    )
  ) %>%
  pivot_longer(
    everything(),
    names_to = c("Source", "Statistic"),
    names_sep = "_(?=[^_]+$)",
    values_to = "Value"
  ) %>%
  pivot_wider(
    names_from = Statistic,
    values_from = Value
  )

print(summary_stats)

# Plot 6: Heatmap of correlations
cor_data <- turnout_comparison_table %>%
  select(State_Turnout, CPS, CES_Unweighted, CES_Weighted, CES_ANESRake_Weighted) %>%
  cor(use = "pairwise.complete.obs")

cor_long <- as.data.frame(cor_data) %>%
  rownames_to_column("Source1") %>%
  pivot_longer(-Source1, names_to = "Source2", values_to = "Correlation")

p6 <- ggplot(cor_long, aes(x = Source1, y = Source2, fill = Correlation)) +
  geom_tile() +
  geom_text(aes(label = round(Correlation, 2)), color = "white", size = 4) +
  scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0.5) +
  labs(
    title = "Correlation Matrix of Turnout Sources",
    x = NULL,
    y = NULL
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

print(p6)
```

